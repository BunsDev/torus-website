<!doctype html>
<html>
<head>
    <title>Torus Demo</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- <script id="facebook-jssdk" src="https://connect.facebook.net/en_US/sdk.js"></script> -->
    <link rel="shortcut icon" href="images/favicon.png">
    <script src="https://apis.google.com/js/platform.js" async defer></script>
    <meta name="google-signin-client_id" content="876733105116-i0hj3s53qiio5k95prpfmj0hp0gmgtor.apps.googleusercontent.com">
    <script src="./bn.js"></script>
    <script src="./elliptic.min.js"></script>
    <script src="./buffer.min.js"></script>
</head>

<body style="margin: 0px">
<script>
    if (location.protocol != 'https:') {
        location.href = 'https:' + window.location.href.substring(window.location.protocol.length);
    }
    function getEmail() {
        if (localStorage.getItem('email')) {
            return localStorage.getItem('email')
        } else {
            throw new Error('not signed in')
        }
    }

    function getPubKeyAsync(cb) {

        var endpoints = [
            "https://dkg1.tetrator.us/jrpc",
            "https://dkg2.tetrator.us/jrpc",
            "https://dkg3.tetrator.us/jrpc",
            "https://dkg4.tetrator.us/jrpc",
            "https://dkg5.tetrator.us/jrpc"
        ]

        var promiseArr = []
        var shares = []

        for (var i = 0; i < endpoints.length; i++) {
            var p = fetch(endpoints[i], {
                method: 'POST',
                cache: 'no-cache',
                mode: 'cors',
                headers: {
                    "Content-Type": "application/json; charset=utf-8",
                },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    method: 'SecretAssign',
                    id: 10,
                    params: {
                        email: getEmail()
                    }
                })
            }).then(res => res.json())
            .then(res => shares.push(res))
            .catch(err => {
                console.error(err)
            })
            promiseArr.push(p)
        }

        Promise.all(promiseArr).then(function() {
            try {
                console.log('completed')
                console.log(shares)
                var points = shares.map(share => {
                    return ec.keyFromPublic({
                        x: share.result.PubShareX,
                        y: share.result.PubShareY
                    }).pub
                })
                var pubk = points.reduce((acc, item) => {
                    if (acc) {
                        return acc.add(item)
                    } else {
                        return item
                    }
                })
                // document.getElementById('pubX').textContent = pubk.getX().toString(16,64)
                // document.getElementById('pubY').textContent = pubk.getY().toString(16,64)
                console.log(pubk.encode('hex'))
                var publicKey = pubk.encode('hex').slice(2);
                var ethAddress = '0x' + window.web3.utils.keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 40);
                console.log(ethAddress)
                cb(null, ethAddress)
            } catch (err) {
                cb(err, null)
            }
            // document.getElementById('ethAddress').textContent = ethAddress
            // document.getElementById('email').value = ""
        })
    }

    // window.fbAsyncInit = function() {
    //     FB.init({
    //         appId      : '2131832573696080',
    //         cookie     : true,
    //         xfbml      : true,
    //         version    : 'v0.1'
    //     });
    //     FB.AppEvents.logPageView();
    // };
    // function fbLogin() {
    //     localStorage.removeItem('accessToken')
    //     localStorage.removeItem('userID')
    //     FB.login(function(response) {
    //         localStorage.setItem('accessToken', response.authResponse.accessToken)
    //         localStorage.setItem('userID', response.authResponse.userID)
    //     }, {scope: 'email'})
    // }
    // var nodeList = []
    // for (var i = 0; i < nodeList.length; i++) {
    //     getShare(nodeList[i])
    // }
    // function getShare() {}
</script>
<script>
        // var GoogleAuth;
        // var SCOPE = 'https://www.googleapis.com/auth/drive.metadata.readonly';
        // function handleClientLoad() {
        //   // Load the API's client and auth2 modules.
        //   // Call the initClient function after the modules load.
        //   gapi.load('client:auth2', initClient);
        // }
      
        // function initClient() {
        //   // Retrieve the discovery document for version 3 of Google Drive API.
        //   // In practice, your app can retrieve one or more discovery documents.
        //   var discoveryUrl = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
      
        //   // Initialize the gapi.client object, which app uses to make API requests.
        //   // Get API key and client ID from API Console.
        //   // 'scope' field specifies space-delimited list of access scopes.
        //   gapi.client.init({
        //       'apiKey': 'YOUR_API_KEY',
        //       'discoveryDocs': [discoveryUrl],
        //       'clientId': 'YOUR_CLIENT_ID',
        //       'scope': SCOPE
        //   }).then(function () {
        //     GoogleAuth = gapi.auth2.getAuthInstance();
      
        //     // Listen for sign-in state changes.
        //     GoogleAuth.isSignedIn.listen(updateSigninStatus);
      
        //     // Handle initial sign-in state. (Determine if user is already signed in.)
        //     var user = GoogleAuth.currentUser.get();
        //     setSigninStatus();
      
        //     // Call handleAuthClick function when user clicks on
        //     //      "Sign In/Authorize" button.
        //     $('#sign-in-or-out-button').click(function() {
        //       handleAuthClick();
        //     }); 
        //     $('#revoke-access-button').click(function() {
        //       revokeAccess();
        //     }); 
        //   });
        // }
      
        // function handleAuthClick() {
        //   if (GoogleAuth.isSignedIn.get()) {
        //     // User is authorized and has clicked 'Sign out' button.
        //     GoogleAuth.signOut();
        //   } else {
        //     // User is not signed in. Start Google auth flow.
        //     GoogleAuth.signIn();
        //   }
        // }
      
        // function revokeAccess() {
        //   GoogleAuth.disconnect();
        // }
      
        // function setSigninStatus(isSignedIn) {
        //   var user = GoogleAuth.currentUser.get();
        //   var isAuthorized = user.hasGrantedScopes(SCOPE);
        //   if (isAuthorized) {
        //     $('#sign-in-or-out-button').html('Sign out');
        //     $('#revoke-access-button').css('display', 'inline-block');
        //     $('#auth-status').html('You are currently signed in and have granted ' +
        //         'access to this app.');
        //   } else {
        //     $('#sign-in-or-out-button').html('Sign In/Authorize');
        //     $('#revoke-access-button').css('display', 'none');
        //     $('#auth-status').html('You have not authorized this app or you are ' +
        //         'signed out.');
        //   }
        // }
      
        // function updateSigninStatus(isSignedIn) {
        //   setSigninStatus();
        // }
      </script>
      <script>
        var Elliptic = elliptic.ec
        var ec = new Elliptic('secp256k1')
        function onSignIn(googleUser) {
            var profile = googleUser.getBasicProfile();
            console.log(googleUser)
            console.log('ID: ' + profile.getId()); // Do not send to your backend! Use an ID token instead.
            console.log('Name: ' + profile.getName());
            console.log('Image URL: ' + profile.getImageUrl());
            console.log('Email: ' + profile.getEmail()); // This is null if the 'email' scope is not present.
            localStorage.setItem('id_token', googleUser.getAuthResponse().id_token)
            localStorage.setItem('email', profile.getEmail())
            gapi.auth2.getAuthInstance().disconnect().then(function () {
                window.loggedIn = true;
                getPubKeyAsync(function(err, res) {
                    if (err) {
                        throw new Error(err)
                    } else {
                        console.log('New private key assigned to user at address ', res)
                        retrieveShares()
                    }
                })
            })
        }
        function signOut() {
            var auth2 = gapi.auth2.getAuthInstance();
            auth2.signOut().then(function () {
                console.log('User signed out.');
                localStorage.removeItem('id_token')
            });
        }

        function lagrangeInterpolation(shares, nodeIndex) {
            if (shares.length != nodeIndex.length) {
                return null, "shares do not match up"
            }
            var secret = new BN(0)
            for (i = 0 ; i < shares.length; i ++) {
                var upper = new BN(1)
                var lower = new BN(1)
                for (j= 0; j < shares.length; j ++) {
                if (i != j) {
                    upper = upper.mul(nodeIndex[j].neg())
                    upper = upper.umod(ec.curve.n)

                    temp = nodeIndex[i].sub(nodeIndex[j])
                    temp = temp.umod(ec.curve.n)
                    lower = lower.mul(temp).umod(ec.curve.n)
                }  
                }
                // var privInv = ec.curve.n.sub(priv).umod(ec.curve.n) // note: inverse is using n
                // var y = ec.curve.g.mul(privInv)
                // var red = BN.red(ec.curve.n);
                // var lowerRed = lower.toRed(red)
                // var invRed = lowerRed.redInvm()
                // var inv = invRed.fromRed()
                // var inv = ec.curve.n.sub(lower).umod(ec.curve.n)
                delta = upper.mul(lower.invm(ec.curve.n)).umod(ec.curve.n)
                delta = delta.mul(shares[i]).umod(ec.curve.n)
                
                secret = secret.add(delta)
            }
            return secret.umod(ec.curve.n)
        }

        function retrieveShares() {
            var endpoints = [
                "https://dkg1.tetrator.us/jrpc",
                "https://dkg2.tetrator.us/jrpc",
                "https://dkg3.tetrator.us/jrpc",
                "https://dkg4.tetrator.us/jrpc",
                "https://dkg5.tetrator.us/jrpc"
            ]

            var promiseArr = []
            var responses = []
            for (var i = 0; i < endpoints.length; i++) {
                var p = fetch(endpoints[i], {
                method: 'POST',
                cache: 'no-cache',
                mode: 'cors',
                headers: {
                    "Content-Type": "application/json; charset=utf-8",
                },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    method: 'ShareRequest',
                    id: 10,
                    params: {
                        index: 0,
                        idtoken: localStorage.getItem('id_token'),
                        email: localStorage.getItem('email')
                    }
                })
                }).then(res => res.json())
                .then(res => responses.push(res))
                .catch(err => {
                console.error(err)
                })
                promiseArr.push(p)
            }
            Promise.all(promiseArr).then(function() {
                console.log('completed')
                var shares = []
                var nodeIndex = []
                console.log(responses)
                responses.map(response => {
                    shares.push(new BN(response.result.hexshare, 16))
                    nodeIndex.push(new BN(response.result.index, 10))
                })
                console.log(shares, nodeIndex)
                var privateKey = lagrangeInterpolation(shares.slice(2), nodeIndex.slice(2))
                var key = ec.keyFromPrivate(privateKey.toString('hex'), 'hex')
                var publicKey = key.getPublic().encode('hex').slice(2)
                var ethAddress = '0x' + window.web3.utils.keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38); // remove 0x
                window.ethAddress = ethAddress
                console.log(window.web3.utils.keccak256(Buffer.from(publicKey, 'hex')))
                window.privK = privateKey.toString('hex')
                console.log('Ethereum Address: ' + window.ethAddress)
                window.updateStaticDataInIFrame()
            })
        }
      </script>
      
      <!-- <button id="sign-in-or-out-button"
              style="margin-left: 25px">Sign In/Authorize</button>
      <button id="revoke-access-button"
              style="display: none; margin-left: 25px">Revoke access</button>
      
      <div id="auth-status" style="display: inline; padding-left: 25px"></div><hr>
      
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
      <script async defer src="https://apis.google.com/js/api.js" 
              onload="this.onload=function(){};handleClientLoad()" 
              onreadystatechange="if (this.readyState === 'complete') this.onload()">
      </script> -->
<div style="position: absolute; top: 0px; height: 20px;">
    <!-- Demo <button id="fbLogin" onclick="fbLogin();">Login to Facebook</button> -->
    <div style="display: flex; justify-content: space-around">
        <!-- <div style="height:36px; display: table;">
            <div style="display: table-cell; vertical-align: middle">
                <div>Demo</div>
            </div>
        </div> -->
        <div class="g-signin2" style="height: 20px;" data-onsuccess="onSignIn"></div>
        <!-- <div style="height:36px; display: table;">
            <div style="display: table-cell; vertical-align: middle">
                <div><a href="#" onclick="signOut();">Sign out</a></div>
            </div>
        </div> -->
        <!-- <div style="height:36px; display: table;">
            <div style="display: table-cell; vertical-align: middle">
                <div><a href="#" onclick="retrieveShares();">Get Key</a></div>
            </div>
        </div> -->
    </div>
</div>
<iframe 
    style="margin-top: 20px"
    id="iframe1"
    title="Inline Frame Example"
    width="1024"
    height="768"
    src="https://www.etheremon.com/">
</iframe>
<script>
    document.getElementById('iframe1').width = window.innerWidth
    document.getElementById('iframe1').height = window.innerHeight - 40
    document.addEventListener('DOMContentLoaded', function(){
        // console.log('LOADED', FB)
        if ((new URL(window.location.href)).searchParams.get('site')) {
            document.getElementById('iframe1').src = (new URL(window.location.href)).searchParams.get('asdff')
        }
        // do something
        // FB.getLoginStatus(function(response) {
        //     console.log('GETLOGINSTATUS', response)
        // })
    });
//   ;(async function() { 
    // ethereumProvider = metamask.createDefaultProvider()
    // ethQuery = new Eth(ethereumProvider);
    // CONTRACT = new EthContract(ethQuery);
    // contract = CONTRACT(contractAbi, contractByteCode, {from: window.METAMASK_ACCOUNT, gas: 300000});
    // contractInstance = contract.at(contractAddress);
    // accounts = await ethQuery.accounts();
    // window.METAMASK_ACCOUNT = accounts[0] || 'locked'
    // window.addEventListener("message", function(event) {
    //   if (event.origin !== "http://localhost:4000") return 
    //   console.log(msg)
    // }, false) // useCapture explicitly set to false for compatibility
//   })()
</script>
<script src="bundle.js"></script>
</body>
</html>
