self.__precacheManifest = (self.__precacheManifest || []).concat([
  {
    'revision': '8d6206516fe316377d277ebb3bf4989f',
    'url': '/54d46a2b461f887b3434.worker.js'
  },
  {
    'revision': '76872d4f3e91f6a488edfdf76fadbe7d',
    'url': '/css/circles.css'
  },
  {
    'revision': '1fb2faafdd81b4c2ae089a7896362c06',
    'url': '/css/error-page.css'
  },
  {
    'revision': 'f69e14bc4329ea9a9ecbadee168ea08a',
    'url': '/css/vendor/animate.css'
  },
  {
    'revision': '81d49393f3b1a028fa7a0649c31cda16',
    'url': '/css/widget.css'
  },
  {
    'revision': 'dd79517d4ed73689b43bfd0783b66ad0',
    'url': '/embed-temp.min.js'
  },
  {
    'revision': '5e9ec02daf4ad3e4a572113cdd53c557',
    'url': '/embed.min.js'
  },
  {
    'revision': 'a55609d1bd5761db054d058b99b06d74',
    'url': '/embed.user.js'
  },
  {
    'revision': '90a320a4947a745b2ce634831296ff17',
    'url': '/error-pages/404-notfound.html'
  },
  {
    'revision': '59438d39528421a67c8adfed71a667b1',
    'url': '/favicon.png'
  },
  {
    'revision': '498198798a0ebe7312f66b657c8ab496',
    'url': '/images/address-card-regular.svg'
  },
  {
    'revision': 'ea699e588b8d06fd6d66468fb2caf058',
    'url': '/images/blublu-cross-arms.png'
  },
  {
    'revision': '332db86a55c5eb68a3952b965d46498a',
    'url': '/images/blue_arrow_down.svg'
  },
  {
    'revision': '33c3e0914e58f1dc04b17d53a1feea6c',
    'url': '/images/blue_arrow_right.svg'
  },
  {
    'revision': 'a06ef5d61d576d1e5b8c130f2e8b0c8d',
    'url': '/images/clock-regular.svg'
  },
  {
    'revision': '97ab7f9788174843b126d8323db344e5',
    'url': '/images/coins.svg'
  },
  {
    'revision': 'ad96ad1c04cd592f0250395445438f3c',
    'url': '/images/crypto-logo-white.png'
  },
  {
    'revision': '01b907a25bdbe3a352f0edef17686cfe',
    'url': '/images/crypto-logo.png'
  },
  {
    'revision': 'e1b1069a1e388cc64b9eeaa14fb80096',
    'url': '/images/equal.svg'
  },
  {
    'revision': '4616f372535ac665c533596577e964cc',
    'url': '/images/etheremon.png'
  },
  {
    'revision': 'ca7a85473be310b024589873f29a8ae2',
    'url': '/images/ethereum-rainbow.svg'
  },
  {
    'revision': '59438d39528421a67c8adfed71a667b1',
    'url': '/images/favicon.png'
  },
  {
    'revision': '88e49eab4a06159e644f84ab468f2975',
    'url': '/images/favicon_inverted.png'
  },
  {
    'revision': 'e4c95b71c5e4d19e9921605d6d6ed51e',
    'url': '/images/file-signature.svg'
  },
  {
    'revision': 'd5865fa4dfd2bf71c46bb01ed600768a',
    'url': '/images/footer_waves.png'
  },
  {
    'revision': '658a7004ec8e83893a432b76179d33eb',
    'url': '/images/home-illustration.svg'
  },
  {
    'revision': '39c094254559fc5ddf8d178e261d6f28',
    'url': '/images/lavender-mask-rtl.svg'
  },
  {
    'revision': '6bd3f8c2a51121bdc14f66a4625c3c5a',
    'url': '/images/lavender-mask.svg'
  },
  {
    'revision': '1b46c4fd46e7ee9610e7682af5749deb',
    'url': '/images/learn-more-intro.png'
  },
  {
    'revision': '10114dadfd1c8fd1d908e249b3a57c3d',
    'url': '/images/learn-more-intro.svg'
  },
  {
    'revision': '20c7502022d995b59969c68f285c8dec',
    'url': '/images/learn-more.svg'
  },
  {
    'revision': 'c522b4d55461a3276c468425d5a5f9bf',
    'url': '/images/login-bg.png'
  },
  {
    'revision': '95013887d84b8e86c345ee50e436e843',
    'url': '/images/login-with-torus.png'
  },
  {
    'revision': '2a8acc89f8ca7aaff2def89110863918',
    'url': '/images/login.png'
  },
  {
    'revision': '5a714e1593c52a81aafb803ceea91ec1',
    'url': '/images/loginWhite.png'
  },
  {
    'revision': '0498e14522c1c1631d0032671bb4c90b',
    'url': '/images/loginwithgoogle.png'
  },
  {
    'revision': 'c4a8ad7621a285e3506effc03feee87d',
    'url': '/images/logo.png'
  },
  {
    'revision': 'e1144525abf064bbd4e93b00f93f731d',
    'url': '/images/logo2x.png'
  },
  {
    'revision': 'c4faa69c34c2ff998a3e64aad52c3256',
    'url': '/images/logos/0x.svg'
  },
  {
    'revision': 'b3bf5330ba8c542da0680ed6b7243d66',
    'url': '/images/logos/0xbitcoin.svg'
  },
  {
    'revision': '9d0a7b5b08acea1834add164ac6f0d81',
    'url': '/images/logos/1st.svg'
  },
  {
    'revision': '6324814008140eb964b93a8576c2455c',
    'url': '/images/logos/AST.png'
  },
  {
    'revision': '51879606043a35c92e9a5cd7b4cdad1c',
    'url': '/images/logos/Aion.png'
  },
  {
    'revision': 'de8f26e7b560edb6481958c4f17f1609',
    'url': '/images/logos/BAT_icon.svg'
  },
  {
    'revision': '51a2fc7de6ad6ef93972a7c143db7fd6',
    'url': '/images/logos/Brickblock.svg'
  },
  {
    'revision': 'd2e12e421c0a7e161090e5c24077696e',
    'url': '/images/logos/CanYa.svg'
  },
  {
    'revision': '4031aaafd9706b3acf9ee2221bff1996',
    'url': '/images/logos/Cpollo.svg'
  },
  {
    'revision': '432a3a81c4d490c8876f32d96fa09dd7',
    'url': '/images/logos/CryptoKitties-Kitty-13733.svg'
  },
  {
    'revision': 'ca4c3a79d7d9201b008aeb9bd6e38f02',
    'url': '/images/logos/DAOstack.png'
  },
  {
    'revision': '2c6e43f4a88847571c58de41afb6909c',
    'url': '/images/logos/DAY.png'
  },
  {
    'revision': 'a0919881cf30ffa70ce137ce311ecf7f',
    'url': '/images/logos/DGD.png'
  },
  {
    'revision': 'c7f14451304cc1898c82092e0f48eb70',
    'url': '/images/logos/Dentacoin.png'
  },
  {
    'revision': '0b0f7533c8cbde7c4e7a60f9371788d4',
    'url': '/images/logos/ENTRP.png'
  },
  {
    'revision': '72416a98505f5addb16b72119c14ebc0',
    'url': '/images/logos/FEATURED.POP_.png'
  },
  {
    'revision': '9fb315e7e1922985209f46b241e5db4f',
    'url': '/images/logos/IMP.svg'
  },
  {
    'revision': 'f2ee123f48a44495ee0f68593a142aea',
    'url': '/images/logos/J8T.svg'
  },
  {
    'revision': 'bd62956de577d1de47347a8941e09d75',
    'url': '/images/logos/JETCOIN28.png'
  },
  {
    'revision': '3d4f57b223f8fe996f70b52f0152a443',
    'url': '/images/logos/JOY.png'
  },
  {
    'revision': '9bce0945731038d23eea7689f60072ed',
    'url': '/images/logos/MLNSymbol.png'
  },
  {
    'revision': '1d1bde85e2d461239c986f0e6eab6c9b',
    'url': '/images/logos/Maecenas.jpg'
  },
  {
    'revision': 'acf03fbbbd07985820630a0bf828b01e',
    'url': '/images/logos/POA20.png'
  },
  {
    'revision': '001a908254237ccc272d306e83b2c30f',
    'url': '/images/logos/ParetoLogo.png'
  },
  {
    'revision': '3be475d0a2c80191653ccd412540656b',
    'url': '/images/logos/RChain_logo.svg'
  },
  {
    'revision': 'b53824784222daecff987f453a7bb533',
    'url': '/images/logos/Rmesh.png'
  },
  {
    'revision': 'd37b4e909050dce8b1b620152f543820',
    'url': '/images/logos/SPANK.png'
  },
  {
    'revision': '4ebeda123f251fea2102850163fa44f5',
    'url': '/images/logos/SpendCoin.png'
  },
  {
    'revision': '2b52aacd12dda1d961d37067cfe59ee3',
    'url': '/images/logos/StandardBounties.png'
  },
  {
    'revision': 'cb5283761830980fcfef4df4f1d301c1',
    'url': '/images/logos/XSC_Logo.svg'
  },
  {
    'revision': '88f116c90240b8368cf0e441285a14cc',
    'url': '/images/logos/aeternity.svg'
  },
  {
    'revision': '921c287dea77f9c7be2ab55145590c17',
    'url': '/images/logos/appcoins.png'
  },
  {
    'revision': 'd7aa48aa643825c0e7985e91e4b44197',
    'url': '/images/logos/aragon_isotype.svg'
  },
  {
    'revision': '9b6ab62c5cb8ae77ea869051161fcf47',
    'url': '/images/logos/augur_logo.png'
  },
  {
    'revision': 'd3917c5ea92e23424ba127e8497ca9d5',
    'url': '/images/logos/bancor.png'
  },
  {
    'revision': '6ea7f77670e42a88d398c10697586b28',
    'url': '/images/logos/bcap.svg'
  },
  {
    'revision': '401856ddcb20903b883a8d9ef2683104',
    'url': '/images/logos/bcpt.svg'
  },
  {
    'revision': '4b7b6cc2509cedceba217b02efb74ecd',
    'url': '/images/logos/bee_token.svg'
  },
  {
    'revision': 'bf3f2f53fe53e80a0cb0fd846eac618a',
    'url': '/images/logos/bitclave.svg'
  },
  {
    'revision': 'db15ec472dc3097993cb4bdb9e9714a7',
    'url': '/images/logos/bitmart.png'
  },
  {
    'revision': '74b47672a339cf161ce7ef5b18487f35',
    'url': '/images/logos/bnb.png'
  },
  {
    'revision': '92aac46c7929dda625dc7178fbb14791',
    'url': '/images/logos/bobsrepair.png'
  },
  {
    'revision': 'c95f8d33b0b78b889330758375223cd2',
    'url': '/images/logos/box_token.png'
  },
  {
    'revision': '4bd1f50890fa3db38f02cbc540085eae',
    'url': '/images/logos/bytom-2-logo-png-transparent.png'
  },
  {
    'revision': 'd0953f59070b263061fee540207aa17b',
    'url': '/images/logos/c20.svg'
  },
  {
    'revision': 'f5b9ff9e68dfd4f74458123bc34669b5',
    'url': '/images/logos/change.png'
  },
  {
    'revision': 'a79f6b8984e19d603065e1234fe5c007',
    'url': '/images/logos/chronobank.png'
  },
  {
    'revision': '6736fb1c5308aae8c0d0fe75993b028c',
    'url': '/images/logos/cln.png'
  },
  {
    'revision': 'cd3518cfbc66ab72bcd4d648286d67f7',
    'url': '/images/logos/coindirect-dark.svg'
  },
  {
    'revision': '814b399d07b1fec59d78c45e85dd8407',
    'url': '/images/logos/coindirect.svg'
  },
  {
    'revision': '091ce7962edcc6baa2cdc74a6f745fac',
    'url': '/images/logos/crypto-logo.png'
  },
  {
    'revision': 'a4f58176d5487cd8c333c617612033c2',
    'url': '/images/logos/dai.svg'
  },
  {
    'revision': '3077928848bd05efbbdae593597c5d87',
    'url': '/images/logos/decentraland.png'
  },
  {
    'revision': '4d0c55126121ba872d4bc53b6c09641e',
    'url': '/images/logos/dether.svg'
  },
  {
    'revision': '6c36205b016147a33e6e6de43ef9a5a3',
    'url': '/images/logos/disciplina.svg'
  },
  {
    'revision': 'dd1076c299046bb39912913ca55abd8f',
    'url': '/images/logos/divi.svg'
  },
  {
    'revision': '0ab78e59737c5e915cd2ed4e808215af',
    'url': '/images/logos/dragonglass.svg'
  },
  {
    'revision': '68ba762cd69bb8d7efa680433341e153',
    'url': '/images/logos/dutyof.care-square.png'
  },
  {
    'revision': '5f18d23e9e1ae9a11c8cc9235904a4f6',
    'url': '/images/logos/edgeless.jpg'
  },
  {
    'revision': 'e949e5ebe728704e58e6328ff92293b3',
    'url': '/images/logos/edu.svg'
  },
  {
    'revision': 'eab00419defdab9ce7b398f3d5f5d853',
    'url': '/images/logos/ego_badge.png'
  },
  {
    'revision': '32398149eac86dbebe98e346cf918c78',
    'url': '/images/logos/ely.png'
  },
  {
    'revision': 'c195e97ff74f8b62e78f7326f8bbb5f5',
    'url': '/images/logos/ens.svg'
  },
  {
    'revision': '1502ae9479fb9547727538bf577ee89a',
    'url': '/images/logos/eos-logo.jpeg'
  },
  {
    'revision': '19ea3ebea1dcf97843bb1c8d20e02c38',
    'url': '/images/logos/eth.svg'
  },
  {
    'revision': '5f3ec32b8e1fe05b81715ef53c3359c4',
    'url': '/images/logos/fun.svg'
  },
  {
    'revision': '443d6f57bf6db0ac8068f0a401c2cd8a',
    'url': '/images/logos/gee-icon.svg'
  },
  {
    'revision': '9901f9d7956df18ab168cec472bae176',
    'url': '/images/logos/gladius.svg'
  },
  {
    'revision': '72200cb8219dea06425e287d9309d0fa',
    'url': '/images/logos/gnosis.svg'
  },
  {
    'revision': '18239ca90630a35d935c3b82b59b0bb6',
    'url': '/images/logos/goldx.png'
  },
  {
    'revision': '535403df2f0bffdda15e5af9c54376af',
    'url': '/images/logos/golem.svg'
  },
  {
    'revision': 'ea8ca8aae3f8a7c5458a087193354874',
    'url': '/images/logos/groo.png'
  },
  {
    'revision': '3ba9155b54d5edb7828cc5001dfe3b00',
    'url': '/images/logos/guppy.png'
  },
  {
    'revision': 'f5c3ed44047758680a9001af17f195fb',
    'url': '/images/logos/havven.png'
  },
  {
    'revision': '2bba093414fd95e6b1661b15527c6ec9',
    'url': '/images/logos/havven_nusd.png'
  },
  {
    'revision': 'f85312840272804c8ffd336b6db214cf',
    'url': '/images/logos/herocoin_logo.png'
  },
  {
    'revision': '935f38d764353cfbf21cafb162fbb0b2',
    'url': '/images/logos/hg_gbt.png'
  },
  {
    'revision': '7fdfcb75f752cd355159c16b6a5d038a',
    'url': '/images/logos/hgt.png'
  },
  {
    'revision': '65d38460a495a702a769d9e05ae7b994',
    'url': '/images/logos/hydro.png'
  },
  {
    'revision': '82f6eb6da8856b4c725c86ec42660987',
    'url': '/images/logos/icon-icx-logo.png'
  },
  {
    'revision': '2e9b9bb86f342aea888b073459000224',
    'url': '/images/logos/iconomi.png'
  },
  {
    'revision': '68bcdb627fa6cc9d648a18cfbbba16d8',
    'url': '/images/logos/indorseLogo.jpg'
  },
  {
    'revision': '69aae2d3af51bb17f05da29dab3c5b02',
    'url': '/images/logos/ink_protocol.svg'
  },
  {
    'revision': 'e8a0f0edde8434d234c48a5317ed0fe8',
    'url': '/images/logos/iost.png'
  },
  {
    'revision': '5894ec73ab6d10dd8b3f12280d2c9b24',
    'url': '/images/logos/iqeon.svg'
  },
  {
    'revision': 'a9b5e089b513336e2593a4b758c61b44',
    'url': '/images/logos/knownorigin.svg'
  },
  {
    'revision': '9b43d371044cc7395cf08f54c0e59acd',
    'url': '/images/logos/kucoin.svg'
  },
  {
    'revision': 'c2a1461973721bdfc33874cd68a3e9d8',
    'url': '/images/logos/kyber.svg'
  },
  {
    'revision': '01e1a697ec1fc2916cc1878d2ec8368a',
    'url': '/images/logos/lend.svg'
  },
  {
    'revision': 'a68392c6ef99666dc8c940b4ed2a97b6',
    'url': '/images/logos/like.svg'
  },
  {
    'revision': '36ae0d819e706eab22f9fc0882871b9a',
    'url': '/images/logos/logo-maker-4.svg'
  },
  {
    'revision': '6b3f22f53220078c03493bc6f24043ac',
    'url': '/images/logos/loom.svg'
  },
  {
    'revision': 'fa01f3c871d041550fdec4aaa3c30535',
    'url': '/images/logos/lun.png'
  },
  {
    'revision': '2c64f2fba0fc092cbd49af0218a6e5e4',
    'url': '/images/logos/metamark.svg'
  },
  {
    'revision': '3fb6b04e305ec4a020390110a24c2e06',
    'url': '/images/logos/mithril-featured.png'
  },
  {
    'revision': '027a718fe58e8ca25240d0700892bf75',
    'url': '/images/logos/modum.svg'
  },
  {
    'revision': 'a0148981e629c646dc00f66cef16c0f6',
    'url': '/images/logos/nanjcoin.svg'
  },
  {
    'revision': '17809fbca7711e75424f8c8e744faaf8',
    'url': '/images/logos/ndc.png'
  },
  {
    'revision': '659e19ad18d17576ee437e35a9e661c2',
    'url': '/images/logos/neeo.png'
  },
  {
    'revision': '47ac5824bcc9e3872403e1232fa985b1',
    'url': '/images/logos/nfticon.png'
  },
  {
    'revision': 'b99f4a14684934150700997ce6343604',
    'url': '/images/logos/omg.jpg'
  },
  {
    'revision': 'f360cd76f0759e1575cf4d58b59ea0c4',
    'url': '/images/logos/onlive.svg'
  },
  {
    'revision': 'd3151b7e6c3cf8a3c30ed51a2361f3c0',
    'url': '/images/logos/pax.svg'
  },
  {
    'revision': 'fd8ddd0cfdaa76b227f0102f19d5637b',
    'url': '/images/logos/pinakion.svg'
  },
  {
    'revision': '80f82c9e76440d3fe8d3bfe7f8d1b6f4',
    'url': '/images/logos/plat.png'
  },
  {
    'revision': '979dfc8242ed121d71d84ae1b893c131',
    'url': '/images/logos/playkey.svg'
  },
  {
    'revision': 'c7a8f72536e737eacc625c1f02ba4c80',
    'url': '/images/logos/plutus-god.svg'
  },
  {
    'revision': 'c79e09617bda48de2465379f93821799',
    'url': '/images/logos/polyswarm_nectar.svg'
  },
  {
    'revision': '1aa66e98c53920e6ff46a80cae326f00',
    'url': '/images/logos/qtum_28.png'
  },
  {
    'revision': '257b4fdcf4d71d43d53fc9351aa4182f',
    'url': '/images/logos/quant-network.svg'
  },
  {
    'revision': '8d037c425b51c1cda81fd1402669cab1',
    'url': '/images/logos/rchain.png'
  },
  {
    'revision': 'e7244bdc7b7153258b1df4c7c24e70f2',
    'url': '/images/logos/redcab.png'
  },
  {
    'revision': '17793fd4fbcc767c0ada4d02149419b7',
    'url': '/images/logos/ren.svg'
  },
  {
    'revision': '078daceda13c42096e93513205c08397',
    'url': '/images/logos/request-network.png'
  },
  {
    'revision': '9c9993121ae584272148a64de8bd9f92',
    'url': '/images/logos/rfr.svg'
  },
  {
    'revision': 'dc2ef8c73522925b5c7a38926b0d46e6',
    'url': '/images/logos/rivetz.png'
  },
  {
    'revision': 'd350f8977792c2882b75f0d741a094d4',
    'url': '/images/logos/rlc.svg'
  },
  {
    'revision': '5b4b106c1c66c01874cbfe2fc0bb9298',
    'url': '/images/logos/rock2.png'
  },
  {
    'revision': 'cdc647b47616f5c5a1fe6590153e2be4',
    'url': '/images/logos/santiment.svg'
  },
  {
    'revision': '04914ceb5de90354c8de3f81d0129f4e',
    'url': '/images/logos/singulardtv.svg'
  },
  {
    'revision': 'fc26c015c6884b58a28fd182782f3f96',
    'url': '/images/logos/snt.svg'
  },
  {
    'revision': '8220c9f8b4f3fc20f4fcd662a86a6c3b',
    'url': '/images/logos/spectiv.svg'
  },
  {
    'revision': '10b9613132ba16cb5c1a459fb934244a',
    'url': '/images/logos/spn.svg'
  },
  {
    'revision': '2e5d3b6e7afa527bc16207b8337b8ba3',
    'url': '/images/logos/starbase.png'
  },
  {
    'revision': '99a9d4566b9f74c456f5deb608618de3',
    'url': '/images/logos/stasis-eurs.svg'
  },
  {
    'revision': 'c8960aa02781ad89e8ef07e1579fa986',
    'url': '/images/logos/storj.jpg'
  },
  {
    'revision': 'a67c7f90fe02f547865d6056414342cd',
    'url': '/images/logos/streamr.svg'
  },
  {
    'revision': '16691a5f03856e590f430468b67acd46',
    'url': '/images/logos/swarm.svg'
  },
  {
    'revision': '2689b7a9d921183eb7a2aa22fdca6274',
    'url': '/images/logos/swt.jpg'
  },
  {
    'revision': 'd255419094be82dcc066cacd26fba388',
    'url': '/images/logos/synthetix.svg'
  },
  {
    'revision': 'f8bf35bb5f394bb6e512787b11a81cf2',
    'url': '/images/logos/synthetix_susd.svg'
  },
  {
    'revision': '8ed40d0825ae5be69dfe624c8d0d2955',
    'url': '/images/logos/taas-ico.png'
  },
  {
    'revision': '76e58dfff7633c601de9dfa36677beef',
    'url': '/images/logos/tkn.svg'
  },
  {
    'revision': '845d44e2927d7cc6b31ff329d58ed90d',
    'url': '/images/logos/too-real.jpg'
  },
  {
    'revision': '2e12e26878e9b354f836ee8535cb0966',
    'url': '/images/logos/tpt.png'
  },
  {
    'revision': 'c7cb5d85e9da1d03919c8fd2a068c5f2',
    'url': '/images/logos/trustcoin.jpg'
  },
  {
    'revision': '20286233f190a9622f53e420bac829bb',
    'url': '/images/logos/tusd.png'
  },
  {
    'revision': '2d25df1050166761d4b1a64864124863',
    'url': '/images/logos/vechain.png'
  },
  {
    'revision': '9b6d623f64846dcb82b9768b0e6e880d',
    'url': '/images/logos/viewly.svg'
  },
  {
    'revision': 'fa77afa0f119cd86ba015c86ee0fce34',
    'url': '/images/logos/vslice.png'
  },
  {
    'revision': 'b82c705ff675cbe35cd19a71daa7d585',
    'url': '/images/logos/waltonchain.png'
  },
  {
    'revision': 'c48a16f68f3fd359bb6d9bd5c930087c',
    'url': '/images/logos/weth.png'
  },
  {
    'revision': '1792566b368f6d44b051a05c48d0febd',
    'url': '/images/logos/wings_logo.svg'
  },
  {
    'revision': '7616cc122d942a14812fc56412df0597',
    'url': '/images/logos/wyvern-logo.svg'
  },
  {
    'revision': '1674962542bf513bf04c4e305ec517c4',
    'url': '/images/logos/xaurum_logo.svg'
  },
  {
    'revision': 'b3e0db2b9af18dbb7e13d6f7d1991fe8',
    'url': '/images/logos/yggdrash.svg'
  },
  {
    'revision': '76e289abb6bacce40499f5db8b4e1998',
    'url': '/images/logos/zilliqa.svg'
  },
  {
    'revision': '361350c795de9470bdf8045715f7f98c',
    'url': '/images/moon-pay-logo-white.svg'
  },
  {
    'revision': '90c078288c2ada22818eb289ccdbafce',
    'url': '/images/moon-pay-logo.svg'
  },
  {
    'revision': '48898c3a40583bb3b2da97c66410d45a',
    'url': '/images/people_error.svg'
  },
  {
    'revision': '854a9aa70aaf7c823005c61cc51404f7',
    'url': '/images/plus.svg'
  },
  {
    'revision': '4577933694e7b3f094967514d8b93015',
    'url': '/images/signature.png'
  },
  {
    'revision': '4c470b92d84cdc9bbbb249e20d626f22',
    'url': '/images/signature.svg'
  },
  {
    'revision': '32c80ffe22b27a69d1f115e315e2e120',
    'url': '/images/simplex-logo.png'
  },
  {
    'revision': '5c2eb9617ac16c51b5f7a62a58716d43',
    'url': '/images/sync-blue.svg'
  },
  {
    'revision': 'fd31d1c2e79001f3a115c42912af7f3a',
    'url': '/images/torus-circle.png'
  },
  {
    'revision': '12d37b37913d12eb5db2e2d604166217',
    'url': '/images/torus-circle.svg'
  },
  {
    'revision': '7d2a4a6b01c2b4f55aefa862c441e85f',
    'url': '/images/torus-logo-blue.svg'
  },
  {
    'revision': 'eec7a513f43ebeb7c0036c11d79833b0',
    'url': '/images/torus-logo-white.svg'
  },
  {
    'revision': '6b0030906ea58b58c263930c39f0d8bd',
    'url': '/images/torus-people-colored.svg'
  },
  {
    'revision': '5e7d2e6f35e9c4f7ec2e81fc2a30fa36',
    'url': '/images/torus-people.png'
  },
  {
    'revision': '8589e528c2b5fe9c316643c6c595a91c',
    'url': '/images/torus_logo.png'
  },
  {
    'revision': 'dd850e29820534d8008cbfc11b8c9ca0',
    'url': '/images/user.svg'
  },
  {
    'revision': '2406dff7e2f8b2e39bdd516b89716fbc',
    'url': '/images/wallet-blue.svg'
  },
  {
    'revision': 'a13a6a84dfc8f9c231f2adc113247f51',
    'url': '/images/wallet.svg'
  },
  {
    'revision': '62bb6515a54627a15ec79074f2ea038b',
    'url': '/images/wallet_blue_line.svg'
  },
  {
    'revision': '73ac53d96dc4c8f95d11a8dff9b89ad5',
    'url': '/images/wyre-logo-white.svg'
  },
  {
    'revision': '41ddc8399c9eb0b7556c8decc77f03bb',
    'url': '/images/wyre-logo.svg'
  },
  {
    'revision': 'c4faa69c34c2ff998a3e64aad52c3256',
    'url': '/img/0x.c4faa69c.svg'
  },
  {
    'revision': 'b3bf5330ba8c542da0680ed6b7243d66',
    'url': '/img/0xbitcoin.b3bf5330.svg'
  },
  {
    'revision': '9d0a7b5b08acea1834add164ac6f0d81',
    'url': '/img/1st.9d0a7b5b.svg'
  },
  {
    'revision': '6324814008140eb964b93a8576c2455c',
    'url': '/img/AST.63248140.png'
  },
  {
    'revision': '51879606043a35c92e9a5cd7b4cdad1c',
    'url': '/img/Aion.51879606.png'
  },
  {
    'revision': 'de8f26e7b560edb6481958c4f17f1609',
    'url': '/img/BAT_icon.de8f26e7.svg'
  },
  {
    'revision': '51a2fc7de6ad6ef93972a7c143db7fd6',
    'url': '/img/Brickblock.51a2fc7d.svg'
  },
  {
    'revision': 'd2e12e421c0a7e161090e5c24077696e',
    'url': '/img/CanYa.d2e12e42.svg'
  },
  {
    'revision': '4031aaafd9706b3acf9ee2221bff1996',
    'url': '/img/Cpollo.4031aaaf.svg'
  },
  {
    'revision': '432a3a81c4d490c8876f32d96fa09dd7',
    'url': '/img/CryptoKitties-Kitty-13733.432a3a81.svg'
  },
  {
    'revision': 'ca4c3a79d7d9201b008aeb9bd6e38f02',
    'url': '/img/DAOstack.ca4c3a79.png'
  },
  {
    'revision': '2c6e43f4a88847571c58de41afb6909c',
    'url': '/img/DAY.2c6e43f4.png'
  },
  {
    'revision': 'a0919881cf30ffa70ce137ce311ecf7f',
    'url': '/img/DGD.a0919881.png'
  },
  {
    'revision': 'c7f14451304cc1898c82092e0f48eb70',
    'url': '/img/Dentacoin.c7f14451.png'
  },
  {
    'revision': '0b0f7533c8cbde7c4e7a60f9371788d4',
    'url': '/img/ENTRP.0b0f7533.png'
  },
  {
    'revision': '9fb315e7e1922985209f46b241e5db4f',
    'url': '/img/IMP.9fb315e7.svg'
  },
  {
    'revision': 'f2ee123f48a44495ee0f68593a142aea',
    'url': '/img/J8T.f2ee123f.svg'
  },
  {
    'revision': 'bd62956de577d1de47347a8941e09d75',
    'url': '/img/JETCOIN28.bd62956d.png'
  },
  {
    'revision': '3d4f57b223f8fe996f70b52f0152a443',
    'url': '/img/JOY.3d4f57b2.png'
  },
  {
    'revision': '9bce0945731038d23eea7689f60072ed',
    'url': '/img/MLNSymbol.9bce0945.png'
  },
  {
    'revision': '1d1bde85e2d461239c986f0e6eab6c9b',
    'url': '/img/Maecenas.1d1bde85.jpg'
  },
  {
    'revision': 'acf03fbbbd07985820630a0bf828b01e',
    'url': '/img/POA20.acf03fbb.png'
  },
  {
    'revision': '001a908254237ccc272d306e83b2c30f',
    'url': '/img/ParetoLogo.001a9082.png'
  },
  {
    'revision': '3be475d0a2c80191653ccd412540656b',
    'url': '/img/RChain_logo.3be475d0.svg'
  },
  {
    'revision': 'b53824784222daecff987f453a7bb533',
    'url': '/img/Rmesh.b5382478.png'
  },
  {
    'revision': 'd37b4e909050dce8b1b620152f543820',
    'url': '/img/SPANK.d37b4e90.png'
  },
  {
    'revision': '4ebeda123f251fea2102850163fa44f5',
    'url': '/img/SpendCoin.4ebeda12.png'
  },
  {
    'revision': '2b52aacd12dda1d961d37067cfe59ee3',
    'url': '/img/StandardBounties.2b52aacd.png'
  },
  {
    'revision': 'cb5283761830980fcfef4df4f1d301c1',
    'url': '/img/XSC_Logo.cb528376.svg'
  },
  {
    'revision': '6aeb9c2358756b1430ee966eb80d2fce',
    'url': '/img/account-balance.6aeb9c23.svg'
  },
  {
    'revision': '700412c19880ef14bac654292a2e6b9d',
    'url': '/img/activities.700412c1.svg'
  },
  {
    'revision': '498198798a0ebe7312f66b657c8ab496',
    'url': '/img/address-card-regular.49819879.svg'
  },
  {
    'revision': '88f116c90240b8368cf0e441285a14cc',
    'url': '/img/aeternity.88f116c9.svg'
  },
  {
    'revision': '6613f286ddfaae4db052695b6920729c',
    'url': '/img/android-chrome-192x192.6613f286.png'
  },
  {
    'revision': '2ccd252fce342af4857870e484aeeafc',
    'url': '/img/android-chrome-512x512.2ccd252f.png'
  },
  {
    'revision': '921c287dea77f9c7be2ab55145590c17',
    'url': '/img/appcoins.921c287d.png'
  },
  {
    'revision': '44603a797e2d40f486f85283a85683a3',
    'url': '/img/apple-touch-icon-120x120.44603a79.png'
  },
  {
    'revision': '6b73f62c59b026a88ae7e5ef630ff448',
    'url': '/img/apple-touch-icon-152x152.6b73f62c.png'
  },
  {
    'revision': '38cbd75d404ebeb1710ad628a4aea7ad',
    'url': '/img/apple-touch-icon-180x180.38cbd75d.png'
  },
  {
    'revision': '38cbd75d404ebeb1710ad628a4aea7ad',
    'url': '/img/apple-touch-icon.38cbd75d.png'
  },
  {
    'revision': 'd7aa48aa643825c0e7985e91e4b44197',
    'url': '/img/aragon_isotype.d7aa48aa.svg'
  },
  {
    'revision': '9b6ab62c5cb8ae77ea869051161fcf47',
    'url': '/img/augur_logo.9b6ab62c.png'
  },
  {
    'revision': 'd3917c5ea92e23424ba127e8497ca9d5',
    'url': '/img/bancor.d3917c5e.png'
  },
  {
    'revision': '6ea7f77670e42a88d398c10697586b28',
    'url': '/img/bcap.6ea7f776.svg'
  },
  {
    'revision': '401856ddcb20903b883a8d9ef2683104',
    'url': '/img/bcpt.401856dd.svg'
  },
  {
    'revision': '4b7b6cc2509cedceba217b02efb74ecd',
    'url': '/img/bee_token.4b7b6cc2.svg'
  },
  {
    'revision': 'bf3f2f53fe53e80a0cb0fd846eac618a',
    'url': '/img/bitclave.bf3f2f53.svg'
  },
  {
    'revision': 'db15ec472dc3097993cb4bdb9e9714a7',
    'url': '/img/bitmart.db15ec47.png'
  },
  {
    'revision': 'ea699e588b8d06fd6d66468fb2caf058',
    'url': '/img/blublu-cross-arms.ea699e58.png'
  },
  {
    'revision': '332db86a55c5eb68a3952b965d46498a',
    'url': '/img/blue_arrow_down.332db86a.svg'
  },
  {
    'revision': '33c3e0914e58f1dc04b17d53a1feea6c',
    'url': '/img/blue_arrow_right.33c3e091.svg'
  },
  {
    'revision': '92aac46c7929dda625dc7178fbb14791',
    'url': '/img/bobsrepair.92aac46c.png'
  },
  {
    'revision': '4bd1f50890fa3db38f02cbc540085eae',
    'url': '/img/bytom-2-logo-png-transparent.4bd1f508.png'
  },
  {
    'revision': 'd0953f59070b263061fee540207aa17b',
    'url': '/img/c20.d0953f59.svg'
  },
  {
    'revision': '6135d62ffffc1f5615cfb7a016b97d13',
    'url': '/img/check-circle-primary.6135d62f.svg'
  },
  {
    'revision': '08237967ca99054a607b7bbfa99e8e82',
    'url': '/img/check-circle-white.08237967.svg'
  },
  {
    'revision': 'a79f6b8984e19d603065e1234fe5c007',
    'url': '/img/chronobank.a79f6b89.png'
  },
  {
    'revision': '6736fb1c5308aae8c0d0fe75993b028c',
    'url': '/img/cln.6736fb1c.png'
  },
  {
    'revision': 'a06ef5d61d576d1e5b8c130f2e8b0c8d',
    'url': '/img/clock-regular.a06ef5d6.svg'
  },
  {
    'revision': '2d31cf2a569aba0262fa7c11bc6c505a',
    'url': '/img/close.2d31cf2a.svg'
  },
  {
    'revision': 'cd3518cfbc66ab72bcd4d648286d67f7',
    'url': '/img/coindirect-dark.cd3518cf.svg'
  },
  {
    'revision': '814b399d07b1fec59d78c45e85dd8407',
    'url': '/img/coindirect.814b399d.svg'
  },
  {
    'revision': '97ab7f9788174843b126d8323db344e5',
    'url': '/img/coins.97ab7f97.svg'
  },
  {
    'revision': '3ea174407e09dde63538534fb9b3667c',
    'url': '/img/copy-primary.3ea17440.svg'
  },
  {
    'revision': 'ad96ad1c04cd592f0250395445438f3c',
    'url': '/img/crypto-logo-white.ad96ad1c.png'
  },
  {
    'revision': '01b907a25bdbe3a352f0edef17686cfe',
    'url': '/img/crypto-logo.01b907a2.png'
  },
  {
    'revision': '091ce7962edcc6baa2cdc74a6f745fac',
    'url': '/img/crypto-logo.091ce796.png'
  },
  {
    'revision': 'a4f58176d5487cd8c333c617612033c2',
    'url': '/img/dai.a4f58176.svg'
  },
  {
    'revision': '3077928848bd05efbbdae593597c5d87',
    'url': '/img/decentraland.30779288.png'
  },
  {
    'revision': '4d0c55126121ba872d4bc53b6c09641e',
    'url': '/img/dether.4d0c5512.svg'
  },
  {
    'revision': '6c36205b016147a33e6e6de43ef9a5a3',
    'url': '/img/disciplina.6c36205b.svg'
  },
  {
    'revision': '2e066c33904a804694b60490d84fa804',
    'url': '/img/discord.2e066c33.svg'
  },
  {
    'revision': 'dd1076c299046bb39912913ca55abd8f',
    'url': '/img/divi.dd1076c2.svg'
  },
  {
    'revision': 'ccd3613b40e4365c9b4bc40707ce6f3d',
    'url': '/img/download-primary.ccd3613b.svg'
  },
  {
    'revision': '0ab78e59737c5e915cd2ed4e808215af',
    'url': '/img/dragonglass.0ab78e59.svg'
  },
  {
    'revision': '68ba762cd69bb8d7efa680433341e153',
    'url': '/img/dutyof.care-square.68ba762c.png'
  },
  {
    'revision': '5f18d23e9e1ae9a11c8cc9235904a4f6',
    'url': '/img/edgeless.5f18d23e.jpg'
  },
  {
    'revision': 'e949e5ebe728704e58e6328ff92293b3',
    'url': '/img/edu.e949e5eb.svg'
  },
  {
    'revision': 'eab00419defdab9ce7b398f3d5f5d853',
    'url': '/img/ego_badge.eab00419.png'
  },
  {
    'revision': '32398149eac86dbebe98e346cf918c78',
    'url': '/img/ely.32398149.png'
  },
  {
    'revision': 'c195e97ff74f8b62e78f7326f8bbb5f5',
    'url': '/img/ens.c195e97f.svg'
  },
  {
    'revision': '1502ae9479fb9547727538bf577ee89a',
    'url': '/img/eos-logo.1502ae94.jpeg'
  },
  {
    'revision': 'e1b1069a1e388cc64b9eeaa14fb80096',
    'url': '/img/equal.e1b1069a.svg'
  },
  {
    'revision': 'fb14c84766fcb86c252a81e79ab1aed4',
    'url': '/img/error-circle.fb14c847.svg'
  },
  {
    'revision': '19ea3ebea1dcf97843bb1c8d20e02c38',
    'url': '/img/eth.19ea3ebe.svg'
  },
  {
    'revision': '4616f372535ac665c533596577e964cc',
    'url': '/img/etheremon.4616f372.png'
  },
  {
    'revision': 'ca7a85473be310b024589873f29a8ae2',
    'url': '/img/ethereum-rainbow.ca7a8547.svg'
  },
  {
    'revision': 'cd87c9112107047412dea089639b3bfa',
    'url': '/img/eye-grey.cd87c911.svg'
  },
  {
    'revision': '42dd6131b13fba35235378e675b4d8cd',
    'url': '/img/eye-off-primary.42dd6131.svg'
  },
  {
    'revision': '1e943e693d806892f7ee52b78341e21b',
    'url': '/img/eye-primary.1e943e69.svg'
  },
  {
    'revision': '24bcb97a9a66192309271a9536419675',
    'url': '/img/facebook.24bcb97a.svg'
  },
  {
    'revision': '59438d39528421a67c8adfed71a667b1',
    'url': '/img/favicon.59438d39.png'
  },
  {
    'revision': 'e4c95b71c5e4d19e9921605d6d6ed51e',
    'url': '/img/file-signature.e4c95b71.svg'
  },
  {
    'revision': '3c0068b440638280e85581064ff494be',
    'url': '/img/file-text-grey.3c0068b4.svg'
  },
  {
    'revision': 'd5865fa4dfd2bf71c46bb01ed600768a',
    'url': '/img/footer_waves.d5865fa4.png'
  },
  {
    'revision': '5f3ec32b8e1fe05b81715ef53c3359c4',
    'url': '/img/fun.5f3ec32b.svg'
  },
  {
    'revision': '443d6f57bf6db0ac8068f0a401c2cd8a',
    'url': '/img/gee-icon.443d6f57.svg'
  },
  {
    'revision': '9901f9d7956df18ab168cec472bae176',
    'url': '/img/gladius.9901f9d7.svg'
  },
  {
    'revision': '49420ff26433b61c7bc448a2ab75c3c2',
    'url': '/img/globe.49420ff2.svg'
  },
  {
    'revision': '72200cb8219dea06425e287d9309d0fa',
    'url': '/img/gnosis.72200cb8.svg'
  },
  {
    'revision': '535403df2f0bffdda15e5af9c54376af',
    'url': '/img/golem.535403df.svg'
  },
  {
    'revision': '61a383d07e05daf1970c97fcaace0ab3',
    'url': '/img/google.61a383d0.svg'
  },
  {
    'revision': 'ea8ca8aae3f8a7c5458a087193354874',
    'url': '/img/groo.ea8ca8aa.png'
  },
  {
    'revision': '3ba9155b54d5edb7828cc5001dfe3b00',
    'url': '/img/guppy.3ba9155b.png'
  },
  {
    'revision': 'f5c3ed44047758680a9001af17f195fb',
    'url': '/img/havven.f5c3ed44.png'
  },
  {
    'revision': '2bba093414fd95e6b1661b15527c6ec9',
    'url': '/img/havven_nusd.2bba0934.png'
  },
  {
    'revision': 'f85312840272804c8ffd336b6db214cf',
    'url': '/img/herocoin_logo.f8531284.png'
  },
  {
    'revision': '935f38d764353cfbf21cafb162fbb0b2',
    'url': '/img/hg_gbt.935f38d7.png'
  },
  {
    'revision': '658a7004ec8e83893a432b76179d33eb',
    'url': '/img/home-illustration.658a7004.svg'
  },
  {
    'revision': '2ae8d47b27280262729cc4ae4b4d427a',
    'url': '/img/home.2ae8d47b.svg'
  },
  {
    'revision': '65d38460a495a702a769d9e05ae7b994',
    'url': '/img/hydro.65d38460.png'
  },
  {
    'revision': '82f6eb6da8856b4c725c86ec42660987',
    'url': '/img/icon-icx-logo.82f6eb6d.png'
  },
  {
    'revision': 'fbe0067e1cf1a3142d3b38ee943d1bcb',
    'url': '/img/import-grey.fbe0067e.svg'
  },
  {
    'revision': 'bdc1474e573d5be48f144de2ce3a0772',
    'url': '/img/indent-increase.bdc1474e.svg'
  },
  {
    'revision': '68bcdb627fa6cc9d648a18cfbbba16d8',
    'url': '/img/indorseLogo.68bcdb62.jpg'
  },
  {
    'revision': '884e3d17c1fa28dd1bc603b2585aaa65',
    'url': '/img/info-circle.884e3d17.svg'
  },
  {
    'revision': '546f3b7a3e6f7b1dd790d98b50ba8c1c',
    'url': '/img/info-grey.546f3b7a.svg'
  },
  {
    'revision': '69aae2d3af51bb17f05da29dab3c5b02',
    'url': '/img/ink_protocol.69aae2d3.svg'
  },
  {
    'revision': 'e8a0f0edde8434d234c48a5317ed0fe8',
    'url': '/img/iost.e8a0f0ed.png'
  },
  {
    'revision': '5894ec73ab6d10dd8b3f12280d2c9b24',
    'url': '/img/iqeon.5894ec73.svg'
  },
  {
    'revision': '686efa12d321edcd7dea0bb1b9181450',
    'url': '/img/key-large.686efa12.svg'
  },
  {
    'revision': '2e33094e103a6121b31b52b31e3b97df',
    'url': '/img/key.2e33094e.svg'
  },
  {
    'revision': 'a9b5e089b513336e2593a4b758c61b44',
    'url': '/img/knownorigin.a9b5e089.svg'
  },
  {
    'revision': '9b43d371044cc7395cf08f54c0e59acd',
    'url': '/img/kucoin.9b43d371.svg'
  },
  {
    'revision': 'c2a1461973721bdfc33874cd68a3e9d8',
    'url': '/img/kyber.c2a14619.svg'
  },
  {
    'revision': '39c094254559fc5ddf8d178e261d6f28',
    'url': '/img/lavender-mask-rtl.39c09425.svg'
  },
  {
    'revision': '6bd3f8c2a51121bdc14f66a4625c3c5a',
    'url': '/img/lavender-mask.6bd3f8c2.svg'
  },
  {
    'revision': '10114dadfd1c8fd1d908e249b3a57c3d',
    'url': '/img/learn-more-intro.10114dad.svg'
  },
  {
    'revision': '1b46c4fd46e7ee9610e7682af5749deb',
    'url': '/img/learn-more-intro.1b46c4fd.png'
  },
  {
    'revision': '20c7502022d995b59969c68f285c8dec',
    'url': '/img/learn-more.20c75020.svg'
  },
  {
    'revision': '01e1a697ec1fc2916cc1878d2ec8368a',
    'url': '/img/lend.01e1a697.svg'
  },
  {
    'revision': 'a68392c6ef99666dc8c940b4ed2a97b6',
    'url': '/img/like.a68392c6.svg'
  },
  {
    'revision': '308c6d2d9755887ea10d5b8f32da563a',
    'url': '/img/list.308c6d2d.svg'
  },
  {
    'revision': '3a4e0d511732c5bdbf66bd1dfb235814',
    'url': '/img/lock.3a4e0d51.svg'
  },
  {
    'revision': 'c522b4d55461a3276c468425d5a5f9bf',
    'url': '/img/login-bg.c522b4d5.png'
  },
  {
    'revision': '2a8acc89f8ca7aaff2def89110863918',
    'url': '/img/login.2a8acc89.png'
  },
  {
    'revision': '5a714e1593c52a81aafb803ceea91ec1',
    'url': '/img/loginWhite.5a714e15.png'
  },
  {
    'revision': '0498e14522c1c1631d0032671bb4c90b',
    'url': '/img/loginwithgoogle.0498e145.png'
  },
  {
    'revision': '36ae0d819e706eab22f9fc0882871b9a',
    'url': '/img/logo-maker-4.36ae0d81.svg'
  },
  {
    'revision': 'c4a8ad7621a285e3506effc03feee87d',
    'url': '/img/logo.c4a8ad76.png'
  },
  {
    'revision': 'e1144525abf064bbd4e93b00f93f731d',
    'url': '/img/logo2x.e1144525.png'
  },
  {
    'revision': '6b3f22f53220078c03493bc6f24043ac',
    'url': '/img/loom.6b3f22f5.svg'
  },
  {
    'revision': 'fa01f3c871d041550fdec4aaa3c30535',
    'url': '/img/lun.fa01f3c8.png'
  },
  {
    'revision': '951cdc95af4d49d82237c8adf70e7d1a',
    'url': '/img/menu-primary.951cdc95.svg'
  },
  {
    'revision': '2c64f2fba0fc092cbd49af0218a6e5e4',
    'url': '/img/metamark.2c64f2fb.svg'
  },
  {
    'revision': '3fb6b04e305ec4a020390110a24c2e06',
    'url': '/img/mithril-featured.3fb6b04e.png'
  },
  {
    'revision': '027a718fe58e8ca25240d0700892bf75',
    'url': '/img/modum.027a718f.svg'
  },
  {
    'revision': '7f10af364b5d8f818576305d009634be',
    'url': '/img/money.7f10af36.svg'
  },
  {
    'revision': '361350c795de9470bdf8045715f7f98c',
    'url': '/img/moon-pay-logo-white.361350c7.svg'
  },
  {
    'revision': '90c078288c2ada22818eb289ccdbafce',
    'url': '/img/moon-pay-logo.90c07828.svg'
  },
  {
    'revision': '619804bcfc6a92fbc3c7f1fb62a90c35',
    'url': '/img/msapplication-icon-144x144.619804bc.png'
  },
  {
    'revision': '809da2c57b61515fffe097f2407ca232',
    'url': '/img/mstile-150x150.809da2c5.png'
  },
  {
    'revision': 'a0148981e629c646dc00f66cef16c0f6',
    'url': '/img/nanjcoin.a0148981.svg'
  },
  {
    'revision': '17809fbca7711e75424f8c8e744faaf8',
    'url': '/img/ndc.17809fbc.png'
  },
  {
    'revision': '8191e4098ea40e13e390f544c10088c6',
    'url': '/img/network.8191e409.svg'
  },
  {
    'revision': '47ac5824bcc9e3872403e1232fa985b1',
    'url': '/img/nfticon.47ac5824.png'
  },
  {
    'revision': 'b99f4a14684934150700997ce6343604',
    'url': '/img/omg.b99f4a14.jpg'
  },
  {
    'revision': 'f360cd76f0759e1575cf4d58b59ea0c4',
    'url': '/img/onlive.f360cd76.svg'
  },
  {
    'revision': '73447eb5146b4ff521cc775ed13c5d6b',
    'url': '/img/open-in-new-grey.73447eb5.svg'
  },
  {
    'revision': '2d260bd475e3bb5be636a7633d2675d9',
    'url': '/img/password.2d260bd4.svg'
  },
  {
    'revision': 'd3151b7e6c3cf8a3c30ed51a2361f3c0',
    'url': '/img/pax.d3151b7e.svg'
  },
  {
    'revision': '48898c3a40583bb3b2da97c66410d45a',
    'url': '/img/people_error.48898c3a.svg'
  },
  {
    'revision': 'fd8ddd0cfdaa76b227f0102f19d5637b',
    'url': '/img/pinakion.fd8ddd0c.svg'
  },
  {
    'revision': '80f82c9e76440d3fe8d3bfe7f8d1b6f4',
    'url': '/img/plat.80f82c9e.png'
  },
  {
    'revision': '979dfc8242ed121d71d84ae1b893c131',
    'url': '/img/playkey.979dfc82.svg'
  },
  {
    'revision': '854a9aa70aaf7c823005c61cc51404f7',
    'url': '/img/plus.854a9aa7.svg'
  },
  {
    'revision': 'c7a8f72536e737eacc625c1f02ba4c80',
    'url': '/img/plutus-god.c7a8f725.svg'
  },
  {
    'revision': 'c79e09617bda48de2465379f93821799',
    'url': '/img/polyswarm_nectar.c79e0961.svg'
  },
  {
    'revision': '257b4fdcf4d71d43d53fc9351aa4182f',
    'url': '/img/quant-network.257b4fdc.svg'
  },
  {
    'revision': 'e7244bdc7b7153258b1df4c7c24e70f2',
    'url': '/img/redcab.e7244bdc.png'
  },
  {
    'revision': '3e3d0a92c4d60af6cf0675b8b47d35b2',
    'url': '/img/reddit.3e3d0a92.svg'
  },
  {
    'revision': '17793fd4fbcc767c0ada4d02149419b7',
    'url': '/img/ren.17793fd4.svg'
  },
  {
    'revision': '078daceda13c42096e93513205c08397',
    'url': '/img/request-network.078daced.png'
  },
  {
    'revision': '9c9993121ae584272148a64de8bd9f92',
    'url': '/img/rfr.9c999312.svg'
  },
  {
    'revision': 'dc2ef8c73522925b5c7a38926b0d46e6',
    'url': '/img/rivetz.dc2ef8c7.png'
  },
  {
    'revision': 'd350f8977792c2882b75f0d741a094d4',
    'url': '/img/rlc.d350f897.svg'
  },
  {
    'revision': '5b4b106c1c66c01874cbfe2fc0bb9298',
    'url': '/img/rock2.5b4b106c.png'
  },
  {
    'revision': '3f71b307a5f499f08256cbd29c218374',
    'url': '/img/safari-pinned-tab.3f71b307.svg'
  },
  {
    'revision': 'cdc647b47616f5c5a1fe6590153e2be4',
    'url': '/img/santiment.cdc647b4.svg'
  },
  {
    'revision': '2dd0a2666b7ba39279ca0858fefefef3',
    'url': '/img/server.2dd0a266.svg'
  },
  {
    'revision': '00759a97f9ba32a508e6daa5148b10e1',
    'url': '/img/settings.00759a97.svg'
  },
  {
    'revision': '4577933694e7b3f094967514d8b93015',
    'url': '/img/signature.45779336.png'
  },
  {
    'revision': '4c470b92d84cdc9bbbb249e20d626f22',
    'url': '/img/signature.4c470b92.svg'
  },
  {
    'revision': '32c80ffe22b27a69d1f115e315e2e120',
    'url': '/img/simplex-logo.32c80ffe.png'
  },
  {
    'revision': '04914ceb5de90354c8de3f81d0129f4e',
    'url': '/img/singulardtv.04914ceb.svg'
  },
  {
    'revision': 'fc26c015c6884b58a28fd182782f3f96',
    'url': '/img/snt.fc26c015.svg'
  },
  {
    'revision': '8220c9f8b4f3fc20f4fcd662a86a6c3b',
    'url': '/img/spectiv.8220c9f8.svg'
  },
  {
    'revision': '10b9613132ba16cb5c1a459fb934244a',
    'url': '/img/spn.10b96131.svg'
  },
  {
    'revision': '2e5d3b6e7afa527bc16207b8337b8ba3',
    'url': '/img/starbase.2e5d3b6e.png'
  },
  {
    'revision': '99a9d4566b9f74c456f5deb608618de3',
    'url': '/img/stasis-eurs.99a9d456.svg'
  },
  {
    'revision': 'c8960aa02781ad89e8ef07e1579fa986',
    'url': '/img/storj.c8960aa0.jpg'
  },
  {
    'revision': 'a67c7f90fe02f547865d6056414342cd',
    'url': '/img/streamr.a67c7f90.svg'
  },
  {
    'revision': '16691a5f03856e590f430468b67acd46',
    'url': '/img/swarm.16691a5f.svg'
  },
  {
    'revision': '2689b7a9d921183eb7a2aa22fdca6274',
    'url': '/img/swt.2689b7a9.jpg'
  },
  {
    'revision': '5c2eb9617ac16c51b5f7a62a58716d43',
    'url': '/img/sync-blue.5c2eb961.svg'
  },
  {
    'revision': 'd255419094be82dcc066cacd26fba388',
    'url': '/img/synthetix.d2554190.svg'
  },
  {
    'revision': 'f8bf35bb5f394bb6e512787b11a81cf2',
    'url': '/img/synthetix_susd.f8bf35bb.svg'
  },
  {
    'revision': '8c6031342ffd5c6657bc765d1a3a1ec3',
    'url': '/img/t-fill.8c603134.svg'
  },
  {
    'revision': 'd7a6769321cd33447de67e7704cf0541',
    'url': '/img/t.d7a67693.svg'
  },
  {
    'revision': '35ea7b032a8a18ec5ab6413e88247208',
    'url': '/img/tag.35ea7b03.svg'
  },
  {
    'revision': '76e58dfff7633c601de9dfa36677beef',
    'url': '/img/tkn.76e58dff.svg'
  },
  {
    'revision': '845d44e2927d7cc6b31ff329d58ed90d',
    'url': '/img/too-real.845d44e2.jpg'
  },
  {
    'revision': 'e53e015998a6c8c63f1f6f0ad3f6aa7e',
    'url': '/img/topup.e53e0159.svg'
  },
  {
    'revision': '12d37b37913d12eb5db2e2d604166217',
    'url': '/img/torus-circle.12d37b37.svg'
  },
  {
    'revision': 'fd31d1c2e79001f3a115c42912af7f3a',
    'url': '/img/torus-circle.fd31d1c2.png'
  },
  {
    'revision': 'ea746069095f9e37065113305c8946a0',
    'url': '/img/torus-icon-dark.ea746069.svg'
  },
  {
    'revision': '104183c55a1c6f4bdbcb797735f6ad38',
    'url': '/img/torus-icon-light.104183c5.svg'
  },
  {
    'revision': '7d2a4a6b01c2b4f55aefa862c441e85f',
    'url': '/img/torus-logo-blue.7d2a4a6b.svg'
  },
  {
    'revision': 'eec7a513f43ebeb7c0036c11d79833b0',
    'url': '/img/torus-logo-white.eec7a513.svg'
  },
  {
    'revision': '6b0030906ea58b58c263930c39f0d8bd',
    'url': '/img/torus-people-colored.6b003090.svg'
  },
  {
    'revision': '5e7d2e6f35e9c4f7ec2e81fc2a30fa36',
    'url': '/img/torus-people.5e7d2e6f.png'
  },
  {
    'revision': '8589e528c2b5fe9c316643c6c595a91c',
    'url': '/img/torus_logo.8589e528.png'
  },
  {
    'revision': '2e12e26878e9b354f836ee8535cb0966',
    'url': '/img/tpt.2e12e268.png'
  },
  {
    'revision': '0ed65f0500b3c5ec1720758f12798c60',
    'url': '/img/transaction.0ed65f05.svg'
  },
  {
    'revision': 'c7cb5d85e9da1d03919c8fd2a068c5f2',
    'url': '/img/trustcoin.c7cb5d85.jpg'
  },
  {
    'revision': '20286233f190a9622f53e420bac829bb',
    'url': '/img/tusd.20286233.png'
  },
  {
    'revision': '0a0630343adbfbebca0c2714fdb36eee',
    'url': '/img/twitch.0a063034.svg'
  },
  {
    'revision': 'dd850e29820534d8008cbfc11b8c9ca0',
    'url': '/img/user.dd850e29.svg'
  },
  {
    'revision': '2d25df1050166761d4b1a64864124863',
    'url': '/img/vechain.2d25df10.png'
  },
  {
    'revision': '9b6d623f64846dcb82b9768b0e6e880d',
    'url': '/img/viewly.9b6d623f.svg'
  },
  {
    'revision': '2406dff7e2f8b2e39bdd516b89716fbc',
    'url': '/img/wallet-blue.2406dff7.svg'
  },
  {
    'revision': 'a13a6a84dfc8f9c231f2adc113247f51',
    'url': '/img/wallet.a13a6a84.svg'
  },
  {
    'revision': 'e04ea481bae1dbcea5124f9460a335e1',
    'url': '/img/wallet.e04ea481.svg'
  },
  {
    'revision': '62bb6515a54627a15ec79074f2ea038b',
    'url': '/img/wallet_blue_line.62bb6515.svg'
  },
  {
    'revision': 'b82c705ff675cbe35cd19a71daa7d585',
    'url': '/img/waltonchain.b82c705f.png'
  },
  {
    'revision': '1792566b368f6d44b051a05c48d0febd',
    'url': '/img/wings_logo.1792566b.svg'
  },
  {
    'revision': '73ac53d96dc4c8f95d11a8dff9b89ad5',
    'url': '/img/wyre-logo-white.73ac53d9.svg'
  },
  {
    'revision': '41ddc8399c9eb0b7556c8decc77f03bb',
    'url': '/img/wyre-logo.41ddc839.svg'
  },
  {
    'revision': '7616cc122d942a14812fc56412df0597',
    'url': '/img/wyvern-logo.7616cc12.svg'
  },
  {
    'revision': '1674962542bf513bf04c4e305ec517c4',
    'url': '/img/xaurum_logo.16749625.svg'
  },
  {
    'revision': 'b3e0db2b9af18dbb7e13d6f7d1991fe8',
    'url': '/img/yggdrash.b3e0db2b.svg'
  },
  {
    'revision': '76e289abb6bacce40499f5db8b4e1998',
    'url': '/img/zilliqa.76e289ab.svg'
  },
  {
    'revision': '8d59b4f4088bde156ee8145abae9c1c3',
    'url': '/index.html'
  },
  {
    'revision': '93c6a0b7c4bc7d04f62b',
    'url': '/js/app.1e3c1035.js'
  },
  {
    'revision': '3498585222bcb3646867',
    'url': '/js/chunk-vendors.8d7387d2.js'
  },
  {
    'revision': '406b2813523420c383852eaabf582d30',
    'url': '/js/gapi.js'
  },
  {
    'revision': '3324b01264ea0b304df213a130e2f5a1',
    'url': '/manifest.json'
  },
  {
    'revision': 'a5ff3d66e63a35483e3cbb0606351047',
    'url': '/redirect.html'
  },
  {
    'revision': 'b6216d61c03e6ce0c9aea6ca7808f7ca',
    'url': '/robots.txt'
  },
  {
    'revision': '25b36e4afb82564da570d4b67d5306fe',
    'url': '/sw-base.js'
  },
  {
    'revision': '828b9e4d65058b9cc1526b0455fcd2e8',
    'url': '/sw.js'
  }
]);
// import pre-cache manifest

// workbox port
var precacheController
var listenerAdded = false
var _cacheNameDetails = {
  precache: 'precache-v2',
  prefix: 'workbox',
  suffix: registration.scope
}

function precacheAndRoute(entries, opts) {
  precache(entries)
  addRoute(opts)
}

function addRoute(opts) {
  if (!listenerAdded) {
    addFetchListener(opts)
    listenerAdded = true
  }
}
function addFetchListener(opts) {
  var ignoreURLParametersMatching = opts.ignoreURLParametersMatching || [/^utm_/]
  var directoryIndex = opts.directoryIndex || 'index.html'
  var cleanURLs = opts.cleanURLs === undefined ? true : opts.cleanURLs
  var urlManipulation = opts.urlManipulation
  var cacheName = _createCacheName(_cacheNameDetails.precache)
  addEventListener('fetch', function(event) {
    var precachedURL = getCacheKeyForURL(event.request.url, {
      cleanURLs: cleanURLs,
      directoryIndex: directoryIndex,
      ignoreURLParametersMatching: ignoreURLParametersMatching,
      urlManipulation: urlManipulation
    })
    if (!precachedURL) {
      // console.log('Precacher did not find a match for', event.request.url)
      return
    }
    var responsePromise = caches
      .open(cacheName)
      .then(function(cache) {
        return cache.match(precachedURL)
      })
      .then(function(cachedResponse) {
        if (cachedResponse) {
          return cachedResponse
        }
        console.warn('Precached response not found ', precachedURL)
        return fetch(precachedURL)
      })
    event.respondWith(responsePromise)
  })
}

function _createCacheName(cacheName) {
  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value && value.length > 0).join('-')
}

function getCacheKeyForURL(url, opts) {
  var precacheController = getOrCreatePrecacheController()
  var urlsToCacheKeys = precacheController.getURLsToCacheKeys()
  var variations = generateURLVariations(url, opts)
  for (var i = 0; i < variations.length; i++) {
    var variation = variations[i]
    if (urlsToCacheKeys[variation]) {
      return urlsToCacheKeys[variation]
    }
  }
}

function generateURLVariations(url, opts) {
  var variations = []
  var ignoreURLParametersMatching = opts.ignoreURLParametersMatching
  var directoryIndex = opts.directoryIndex
  var cleanURLs = opts.cleanURLs
  var urlManipulation = opts.urlManipulation
  var urlObject = new URL(url, location.href)
  urlObject.hash = ''
  variations.push(urlObject.href)
  var urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject)
  variations.push(urlWithoutIgnoredParams.href)
  if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {
    var directoryURL = new URL(urlWithoutIgnoredParams.href)
    directoryURL.pathname += directoryIndex
    variations.push(directoryURL.href)
  }
  if (cleanURLs) {
    var cleanURL = new URL(urlWithoutIgnoredParams.href)
    cleanURL.pathname += '.html'
    variations.push(cleanURL.href)
  }
  if (urlManipulation) {
    var additionalURLs = urlManipulation({ url: urlObject })
    additionalURLs.map(function(item) {
      variations.push(item)
    })
  }
  return variations
}

function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching) {
  Object.keys(urlObject.searchParams).map(function(paramName) {
    if (
      ignoreURLParametersMatching.some(function(regExp) {
        regExp.test(paramName)
      })
    ) {
      urlObject.searchParams.delete(paramName)
    }
  })
  return urlObject
}

function precache(entries) {
  var precacheController = getOrCreatePrecacheController()
  precacheController.addToCacheList(entries)
  if (entries.length > 0) {
    addEventListener('install', function(event) {
      var precacheController = getOrCreatePrecacheController()
      event.waitUntil(
        precacheController.install({ event: event }).catch(function(err) {
          console.error(err)
          throw err
        })
      )
    })
    addEventListener('activate', function(event) {
      var precacheController = getOrCreatePrecacheController()
      event.waitUntil(precacheController.activate())
    })
  }
}

function createCacheKey(entry) {
  if (!entry) {
    throw new Error('entry undefined')
  }
  if (typeof entry === 'string') {
    var urlObject = new URL(entry, location.href)
    return {
      cacheKey: urlObject.href,
      url: urlObject.href
    }
  }
  var revision = entry.revision
  var url = entry.url
  if (!url) {
    throw new Error('No url')
  }
  if (!revision) {
    var urlObject = new URL(url, location.href)
    return {
      cacheKey: urlObject.href,
      url: urlObject.href
    }
  }
  var cacheKeyURL = new URL(url, location.href)
  var originalURL = new URL(url, location.href)
  cacheKeyURL.searchParams.set('__WB_REVISION__', revision)
  return {
    cacheKey: cacheKeyURL.href,
    url: originalURL.href
  }
}

function PrecacheController() {
  this._cacheName = _createCacheName(_cacheNameDetails.precache)
  this._urlsToCacheKeys = {}
  this._urlsToCacheModes = {}
  this._cacheKeysToIntegrities = {}
}

PrecacheController.prototype.constructor = PrecacheController

PrecacheController.prototype.addToCacheList = function(entries) {
  var context = this
  try {
    entries.map(function(entry) {
      var obj = createCacheKey(entry)
      var cacheKey = obj.cacheKey
      var url = obj.url
      var cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default'
      if (context._urlsToCacheKeys[url] && context._urlsToCacheKeys[url] !== cacheKey) {
        throw new Error('Conflicting cache key entries ', context._urlsToCacheKeys[url], cacheKey)
      }
      if (typeof entry !== 'string' && entry.integrity) {
        if (context._cacheKeysToIntegrities[cacheKey] && context._cacheKeysToIntegrities[cacheKey] !== entry.integrity) {
          throw new Error('Conflicting integrities ', context._cacheKeysToIntegrities[cacheKey], entry.integrity, url)
        }
        context._cacheKeysToIntegrities[cacheKey] = entry.integrity
      }
      context._urlsToCacheKeys[url] = cacheKey
      context._urlsToCacheModes[url] = cacheMode
    })
  } catch (e) {
    console.error(e)
  }
}

PrecacheController.prototype.install = function(opts) {
  var resolve, reject
  var promise = new Promise(function(res, rej) {
    resolve = res
    reject = rej
  })
  var context = this
  var event = opts.event
  var toBePrecached = []
  var alreadyPrecached = []
  caches
    .open(context._cacheName)
    .then(function(cache) {
      return cache.keys()
    })
    .then(function(alreadyCachedRequests) {
      var existingCacheKeys = alreadyCachedRequests.map(function(req) {
        return req.url
      })
      for (var url in context._urlsToCacheKeys) {
        var cacheKey = context._urlsToCacheKeys[url]
        if (existingCacheKeys[cacheKey]) {
          alreadyPrecached.push(url)
        } else {
          toBePrecached.push({ cacheKey: cacheKey, url: url })
        }
      }
      var precacheRequests = toBePrecached.map(function(obj) {
        var cacheKey = obj.cacheKey
        var url = obj.url
        var integrity = context._cacheKeysToIntegrities[cacheKey]
        var cacheMode = context._urlsToCacheModes[url]
        return context._addURLToCache({
          cacheKey: cacheKey,
          cacheMode: cacheMode,
          event: event,
          integrity: integrity,
          url: url
        })
      })

      Promise.all(precacheRequests).then(function() {
        var updatedURLs = toBePrecached.map(function(item) {
          return item.url
        })
        resolve({
          updatedURLs: updatedURLs,
          notUpdatedURLs: alreadyPrecached
        })
      })
    })

  return promise
}

PrecacheController.prototype.activate = function() {
  var resolve, reject
  var promise = new Promise(function(res, rej) {
    resolve = res
    reject = rej
  })
  var context = this
  var c
  var deletedURLs = []
  caches
    .open(context._cacheName)
    .then(function(cache) {
      c = cache
      return cache.keys()
    })
    .then(function(currentlyCachedRequests) {
      var promises = []
      for (var req in currentlyCachedRequests) {
        if (!context._urlsToCacheKeys[req.url]) {
          promises.push(c.delete(req))
          deletedURLs.push(req.url)
        }
      }
      return Promise.all(promises)
    })
    .then(function() {
      resolve(deletedURLs)
    })

  return promise
}

PrecacheController.prototype._addURLToCache = function(opts) {
  var cacheKey = opts.cacheKey
  var url = opts.url
  var cacheMode = opts.cacheMode
  var event = opts.event
  var integrity = opts.integrity
  var context = this

  var request = new Request(url, {
    integrity: integrity,
    cache: cacheMode,
    credentials: 'same-origin'
  })

  wrappedFetch({
    event: event,
    request: request
  })
    .then(function(response) {
      if (response.status >= 400) {
        throw new Error('Invalid response', url, response.status)
      }
      if (response.redirected) {
        return copyResponse(response)
      }
      return Promise.resolve(response)
    })
    .then(function(response) {
      putWrapper({
        event: event,
        response: response,
        request: cacheKey === url ? request : new Request(cacheKey),
        cacheName: context._cacheName,
        matchOptions: {
          ignoreSearch: true
        }
      })
    })
}

PrecacheController.prototype.getURLsToCacheKeys = function() {
  return this._urlsToCacheKeys
}

PrecacheController.prototype.getCachedURLs = function() {
  return Object.keys(this._urlsToCacheKeys)
}

PrecacheController.prototype.getCacheKeyForURL = function(url) {
  var urlObject = new URL(url, location.href)
  return this._urlsToCacheKeys[urlObject.href]
}

PrecacheController.prototype.createHandlerForURL = function(url) {
  var resolve, reject
  var promies = new Promise(function(res, rej) {
    resolve = res
    reject = rej
  })
  var context = this
  var cacheKey = context.getCacheKeyForURL(url)
  if (!cacheKey) {
    throw new Error('Non-precached URL', url)
  }
  caches
    .open(context._cacheName)
    .then(function(cache) {
      return cache.match(cacheKey)
    })
    .then(function(response) {
      if (response) {
        resolve(response)
      } else {
        reject(new Error('The cache did not have this entry for cacheKey', cacheKey))
      }
    })
    .catch(function(err) {
      console.error('Failed to respond with cached response', err)
      fetch(cacheKey)
        .then(resolve)
        .catch(reject)
    })
  return promise
}

function wrappedFetch(opts) {
  var resolve, reject
  var promise = new Promise(function(res, rej) {
    resolve = res
    reject = rej
  })
  var request = opts.request
  var fetchOptions = opts.fetchOptions
  var event = opts.event
  if (typeof request === 'string') {
    request = new Request(request)
  }
  try {
    var fetchResponse
    if (request.mode === 'navigate') {
      fetch(request)
        .then(resolve)
        .catch(reject)
    } else {
      fetch(request, fetchOptions)
        .then(resolve)
        .catch(reject)
    }
  } catch (e) {
    throw e
  }
  return promise
}

function copyResponse(response) {
  var resolve, reject
  var promise = new Promise(function(res, rej) {
    resolve = res
    reject = rej
  })
  var supportStatus
  function canConstructResponseFromBodyStream() {
    if (supportStatus === undefined) {
      const testResponse = new Response('')
      if ('body' in testResponse) {
        try {
          new Response(testResponse.body)
          supportStatus = true
        } catch (error) {
          supportStatus = false
        }
      }
      supportStatus = false
    }
    return supportStatus
  }
  var clonedResponse = response.clone()
  var responseInit = {
    headers: new Headers(clonedResponse.headers),
    status: clonedResponse.status,
    statusText: clonedResponse.statusText
  }
  var body
  if (canConstructResponseFromBodyStream()) {
    body = clonedResponse.body
    resolve(new Response(body, responseInit))
  } else {
    clonedResponse
      .blob()
      .then(function(b) {
        body = b
        resolve(new Response(body, responseInit))
      })
      .catch(reject)
  }
  return promise
}

function putWrapper(opts) {
  var resolve, reject
  var promise = new Promise(function(res, rej) {
    resolve = res
    reject = rej
  })
  var cacheName = opts.cacheName
  var request = opts.request
  var response = opts.response
  if (response.status !== 200) {
    console.warn('Request not cached')
    resolve()
  }
  caches
    .open(cacheName)
    .then(function(cache) {
      cache.put(request, response).then(resolve)
    })
    .catch(reject)
  return promise
}

function matchWrapper(opts) {
  var resolve, reject
  var promise = new Promise(function(res, rej) {
    resolve = res
    reject = rej
  })
  var cacheName = opts.cacheName
  var request = opts.request
  var event = opts.event
  var matchOptions = opts.matchOptions
  caches
    .open(cacheName)
    .then(function(cache) {
      return cache.match(request, matchOptions)
    })
    .then(function(cachedResponse) {
      resolve(cachedResponse)
    })
    .catch(reject)
  return promise
}

function getOrCreatePrecacheController() {
  if (!precacheController) {
    precacheController = new PrecacheController()
  }
  return precacheController
}

// service worker logic

self.addEventListener('message', function(event) {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
})

self.addEventListener('fetch', function(event) {
  if (event.request.url.indexOf('redirect') > -1) {
    event.respondWith(
      new Response(
        new Blob([
          `
<html>
  <head></head>
  <body>
    <div> Redirecting you back to Torus app... </div>
    <script>
    // broadcast-channel
/* eslint no-param-reassign: 0 */
var broadcastChannelLib = {}
;(function() {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = 'function' == typeof require && require
          if (!f && c) return c(i, !0)
          if (u) return u(i, !0)
          var a = new Error('Cannot find module ' + i)
          throw ((a.code = 'MODULE_NOT_FOUND'), a)
        }
        var p = (n[i] = { exports: {} })
        e[i][0].call(
          p.exports,
          function(r) {
            var n = e[i][1][r]
            return o(n || r)
          },
          p,
          p.exports,
          r,
          e,
          n,
          t
        )
      }
      return n[i].exports
    }
    for (var u = 'function' == typeof require && require, i = 0; i < t.length; i++) o(t[i])
    return o
  }
  return r
})()(
  {
    '/torus/embed.js': [
      function(require, module, exports) {
        broadcastChannelLib.BroadcastChannel = require('broadcast-channel')
      },
      { 'broadcast-channel': '/torus/node_modules/broadcast-channel/dist/lib/index.es5.js' }
    ],
    '/torus/node_modules/@babel/runtime/helpers/interopRequireDefault.js': [
      function(require, module, exports) {
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule
            ? obj
            : {
                default: obj
              }
        }

        module.exports = _interopRequireDefault
      },
      {}
    ],
    '/torus/node_modules/broadcast-channel/dist/lib/index.es5.js': [
      function(require, module, exports) {
        'use strict'

        var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault')

        var _index = _interopRequireDefault(require('./index.js'))

        /**
         * because babel can only export on default-attribute,
         * we use this for the non-module-build
         * this ensures that users do not have to use
         * var BroadcastChannel = require('broadcast-channel').default;
         * but
         * var BroadcastChannel = require('broadcast-channel');
         */
        module.exports = _index['default']
      },
      {
        './index.js': '/torus/node_modules/broadcast-channel/dist/lib/index.js',
        '@babel/runtime/helpers/interopRequireDefault': '/torus/node_modules/@babel/runtime/helpers/interopRequireDefault.js'
      }
    ],
    '/torus/node_modules/broadcast-channel/dist/lib/index.js': [
      function(require, module, exports) {
        'use strict'

        Object.defineProperty(exports, '__esModule', {
          value: true
        })
        exports['default'] = void 0

        var _util = require('./util.js')

        var _methodChooser = require('./method-chooser.js')

        var _options = require('./options.js')

        var BroadcastChannel = function BroadcastChannel(name, options) {
          this.name = name

          if (ENFORCED_OPTIONS) {
            options = ENFORCED_OPTIONS
          }

          this.options = (0, _options.fillOptionsWithDefaults)(options)
          this.method = (0, _methodChooser.chooseMethod)(this.options) // isListening

          this._iL = false
          /**
           * _onMessageListener
           * setting onmessage twice,
           * will overwrite the first listener
           */

          this._onML = null
          /**
           * _addEventListeners
           */

          this._addEL = {
            message: [],
            internal: []
          }
          /**
           * _beforeClose
           * array of promises that will be awaited
           * before the channel is closed
           */

          this._befC = []
          /**
           * _preparePromise
           */

          this._prepP = null

          _prepareChannel(this)
        } // STATICS

        /**
         * used to identify if someone overwrites
         * window.BroadcastChannel with this
         * See methods/native.js
         */

        BroadcastChannel._pubkey = true
        /**
         * clears the tmp-folder if is node
         * @return {Promise<boolean>} true if has run, false if not node
         */

        BroadcastChannel.clearNodeFolder = function(options) {
          options = (0, _options.fillOptionsWithDefaults)(options)
          var method = (0, _methodChooser.chooseMethod)(options)

          if (method.type === 'node') {
            return method.clearNodeFolder().then(function() {
              return true
            })
          } else {
            return Promise.resolve(false)
          }
        }
        /**
         * if set, this method is enforced,
         * no mather what the options are
         */

        var ENFORCED_OPTIONS

        BroadcastChannel.enforceOptions = function(options) {
          ENFORCED_OPTIONS = options
        } // PROTOTYPE

        BroadcastChannel.prototype = {
          postMessage: function postMessage(msg) {
            if (this.closed) {
              throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed')
            }

            return _post(this, 'message', msg)
          },
          postInternal: function postInternal(msg) {
            return _post(this, 'internal', msg)
          },

          set onmessage(fn) {
            var time = this.method.microSeconds()
            var listenObj = {
              time: time,
              fn: fn
            }

            _removeListenerObject(this, 'message', this._onML)

            if (fn && typeof fn === 'function') {
              this._onML = listenObj

              _addListenerObject(this, 'message', listenObj)
            } else {
              this._onML = null
            }
          },

          addEventListener: function addEventListener(type, fn) {
            var time = this.method.microSeconds()
            var listenObj = {
              time: time,
              fn: fn
            }

            _addListenerObject(this, type, listenObj)
          },
          removeEventListener: function removeEventListener(type, fn) {
            var obj = this._addEL[type].find(function(obj) {
              return obj.fn === fn
            })

            _removeListenerObject(this, type, obj)
          },
          close: function close() {
            var _this = this

            if (this.closed) return
            this.closed = true
            var awaitPrepare = this._prepP ? this._prepP : Promise.resolve()
            this._onML = null
            this._addEL.message = []
            return awaitPrepare
              .then(function() {
                return Promise.all(
                  _this._befC.map(function(fn) {
                    return fn()
                  })
                )
              })
              .then(function() {
                return _this.method.close(_this._state)
              })
          },

          get type() {
            return this.method.type
          }
        }

        function _post(broadcastChannel, type, msg) {
          var time = broadcastChannel.method.microSeconds()
          var msgObj = {
            time: time,
            type: type,
            data: msg
          }
          var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : Promise.resolve()
          return awaitPrepare.then(function() {
            return broadcastChannel.method.postMessage(broadcastChannel._state, msgObj)
          })
        }

        function _prepareChannel(channel) {
          var maybePromise = channel.method.create(channel.name, channel.options)

          if ((0, _util.isPromise)(maybePromise)) {
            channel._prepP = maybePromise
            maybePromise.then(function(s) {
              // used in tests to simulate slow runtime

              /*if (channel.options.prepareDelay) {
             await new Promise(res => setTimeout(res, this.options.prepareDelay));
        }*/
              channel._state = s
            })
          } else {
            channel._state = maybePromise
          }
        }

        function _hasMessageListeners(channel) {
          if (channel._addEL.message.length > 0) return true
          if (channel._addEL.internal.length > 0) return true
          return false
        }

        function _addListenerObject(channel, type, obj) {
          channel._addEL[type].push(obj)

          _startListening(channel)
        }

        function _removeListenerObject(channel, type, obj) {
          channel._addEL[type] = channel._addEL[type].filter(function(o) {
            return o !== obj
          })

          _stopListening(channel)
        }

        function _startListening(channel) {
          if (!channel._iL && _hasMessageListeners(channel)) {
            // someone is listening, start subscribing
            var listenerFn = function listenerFn(msgObj) {
              channel._addEL[msgObj.type].forEach(function(obj) {
                if (msgObj.time >= obj.time) {
                  obj.fn(msgObj.data)
                }
              })
            }

            var time = channel.method.microSeconds()

            if (channel._prepP) {
              channel._prepP.then(function() {
                channel._iL = true
                channel.method.onMessage(channel._state, listenerFn, time)
              })
            } else {
              channel._iL = true
              channel.method.onMessage(channel._state, listenerFn, time)
            }
          }
        }

        function _stopListening(channel) {
          if (channel._iL && !_hasMessageListeners(channel)) {
            // noone is listening, stop subscribing
            channel._iL = false
            var time = channel.method.microSeconds()
            channel.method.onMessage(channel._state, null, time)
          }
        }

        var _default = BroadcastChannel
        exports['default'] = _default
      },
      {
        './method-chooser.js': '/torus/node_modules/broadcast-channel/dist/lib/method-chooser.js',
        './options.js': '/torus/node_modules/broadcast-channel/dist/lib/options.js',
        './util.js': '/torus/node_modules/broadcast-channel/dist/lib/util.js'
      }
    ],
    '/torus/node_modules/broadcast-channel/dist/lib/method-chooser.js': [
      function(require, module, exports) {
        'use strict'
        var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault')

        Object.defineProperty(exports, '__esModule', {
          value: true
        })
        exports.chooseMethod = chooseMethod

        var _native = _interopRequireDefault(require('./methods/native.js'))

        var _indexedDb = _interopRequireDefault(require('./methods/indexed-db.js'))

        var _localstorage = _interopRequireDefault(require('./methods/localstorage.js'))

        var _simulate = _interopRequireDefault(require('./methods/simulate.js'))

        var _util = require('./util')

        // order is important
        var METHODS = [
          _native['default'], // fastest
          _indexedDb['default'],
          _localstorage['default']
        ]
        /**
         * The NodeMethod is loaded lazy
         * so it will not get bundled in browser-builds
         */

        if (_util.isNode) {
          /**
           * we use the non-transpiled code for nodejs
           * because it runs faster
           */
          var NodeMethod = require('../../src/methods/' + // use this hack so that browserify and others
            // do not import the node-method by default
            // when bundling.
            'node.js')
          /**
           * this will be false for webpackbuilds
           * which will shim the node-method with an empty object {}
           */

          if (typeof NodeMethod.canBeUsed === 'function') {
            METHODS.push(NodeMethod)
          }
        }

        function chooseMethod(options) {
          // directly chosen
          if (options.type) {
            if (options.type === 'simulate') {
              // only use simulate-method if directly chosen
              return _simulate['default']
            }

            var ret = METHODS.find(function(m) {
              return m.type === options.type
            })
            if (!ret) throw new Error('method-type ' + options.type + ' not found')
            else return ret
          }
          /**
           * if no webworker support is needed,
           * remove idb from the list so that localstorage is been chosen
           */

          var chooseMethods = METHODS

          if (!options.webWorkerSupport && !_util.isNode) {
            chooseMethods = METHODS.filter(function(m) {
              return m.type !== 'idb'
            })
          }

          var useMethod = chooseMethods.find(function(method) {
            return method.canBeUsed()
          })
          if (!useMethod)
            throw new Error(
              'No useable methode found:' +
                JSON.stringify(
                  METHODS.map(function(m) {
                    return m.type
                  })
                )
            )
          else return useMethod
        }
      },
      {
        './methods/indexed-db.js': '/torus/node_modules/broadcast-channel/dist/lib/methods/indexed-db.js',
        './methods/localstorage.js': '/torus/node_modules/broadcast-channel/dist/lib/methods/localstorage.js',
        './methods/native.js': '/torus/node_modules/broadcast-channel/dist/lib/methods/native.js',
        './methods/simulate.js': '/torus/node_modules/broadcast-channel/dist/lib/methods/simulate.js',
        './util': '/torus/node_modules/broadcast-channel/dist/lib/util.js',
        '@babel/runtime/helpers/interopRequireDefault': '/torus/node_modules/@babel/runtime/helpers/interopRequireDefault.js'
      }
    ],
    '/torus/node_modules/broadcast-channel/dist/lib/methods/indexed-db.js': [
      function(require, module, exports) {
        'use strict'
        var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault')

        Object.defineProperty(exports, '__esModule', {
          value: true
        })
        exports.getIdb = getIdb
        exports.createDatabase = createDatabase
        exports.writeMessage = writeMessage
        exports.getAllMessages = getAllMessages
        exports.getMessagesHigherThen = getMessagesHigherThen
        exports.removeMessageById = removeMessageById
        exports.getOldMessages = getOldMessages
        exports.cleanOldMessages = cleanOldMessages
        exports.create = create
        exports.close = close
        exports.postMessage = postMessage
        exports.onMessage = onMessage
        exports.canBeUsed = canBeUsed
        exports.averageResponseTime = averageResponseTime
        exports['default'] = exports.type = exports.microSeconds = void 0

        var _util = require('../util.js')

        var _obliviousSet = _interopRequireDefault(require('../oblivious-set'))

        var _options = require('../options')

        /**
         * this method uses indexeddb to store the messages
         * There is currently no observerAPI for idb
         * @link https://github.com/w3c/IndexedDB/issues/51
         */
        var microSeconds = _util.microSeconds
        exports.microSeconds = microSeconds
        var DB_PREFIX = 'pubkey.broadcast-channel-0-'
        var OBJECT_STORE_ID = 'messages'
        var type = 'idb'
        exports.type = type

        function getIdb() {
          if (typeof indexedDB !== 'undefined') return indexedDB
          if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB
          if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB
          if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB
          return false
        }

        function createDatabase(channelName) {
          var IndexedDB = getIdb() // create table

          var dbName = DB_PREFIX + channelName
          var openRequest = IndexedDB.open(dbName, 1)

          openRequest.onupgradeneeded = function(ev) {
            var db = ev.target.result
            db.createObjectStore(OBJECT_STORE_ID, {
              keyPath: 'id',
              autoIncrement: true
            })
          }

          var dbPromise = new Promise(function(res, rej) {
            openRequest.onerror = function(ev) {
              return rej(ev)
            }

            openRequest.onsuccess = function() {
              res(openRequest.result)
            }
          })
          return dbPromise
        }
        /**
         * writes the new message to the database
         * so other readers can find it
         */

        function writeMessage(db, readerUuid, messageJson) {
          var time = new Date().getTime()
          var writeObject = {
            uuid: readerUuid,
            time: time,
            data: messageJson
          }
          var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite')
          return new Promise(function(res, rej) {
            transaction.oncomplete = function() {
              return res()
            }

            transaction.onerror = function(ev) {
              return rej(ev)
            }

            var objectStore = transaction.objectStore(OBJECT_STORE_ID)
            objectStore.add(writeObject)
          })
        }

        function getAllMessages(db) {
          var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID)
          var ret = []
          return new Promise(function(res) {
            objectStore.openCursor().onsuccess = function(ev) {
              var cursor = ev.target.result

              if (cursor) {
                ret.push(cursor.value) //alert("Name for SSN " + cursor.key + " is " + cursor.value.name);

                cursor['continue']()
              } else {
                res(ret)
              }
            }
          })
        }

        function getMessagesHigherThen(db, lastCursorId) {
          var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID)
          var ret = []
          var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity)
          return new Promise(function(res) {
            objectStore.openCursor(keyRangeValue).onsuccess = function(ev) {
              var cursor = ev.target.result

              if (cursor) {
                ret.push(cursor.value)
                cursor['continue']()
              } else {
                res(ret)
              }
            }
          })
        }

        function removeMessageById(db, id) {
          var request = db
            .transaction([OBJECT_STORE_ID], 'readwrite')
            .objectStore(OBJECT_STORE_ID)
            ['delete'](id)
          return new Promise(function(res) {
            request.onsuccess = function() {
              return res()
            }
          })
        }

        function getOldMessages(db, ttl) {
          var olderThen = new Date().getTime() - ttl
          var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID)
          var ret = []
          return new Promise(function(res) {
            objectStore.openCursor().onsuccess = function(ev) {
              var cursor = ev.target.result

              if (cursor) {
                var msgObk = cursor.value

                if (msgObk.time < olderThen) {
                  ret.push(msgObk) //alert("Name for SSN " + cursor.key + " is " + cursor.value.name);

                  cursor['continue']()
                } else {
                  // no more old messages,
                  res(ret)
                  return
                }
              } else {
                res(ret)
              }
            }
          })
        }

        function cleanOldMessages(db, ttl) {
          return getOldMessages(db, ttl).then(function(tooOld) {
            return Promise.all(
              tooOld.map(function(msgObj) {
                return removeMessageById(db, msgObj.id)
              })
            )
          })
        }

        function create(channelName, options) {
          options = (0, _options.fillOptionsWithDefaults)(options)
          return createDatabase(channelName).then(function(db) {
            var state = {
              closed: false,
              lastCursorId: 0,
              channelName: channelName,
              options: options,
              uuid: (0, _util.randomToken)(10),

              /**
               * emittedMessagesIds
               * contains all messages that have been emitted before
               * @type {ObliviousSet}
               */
              eMIs: new _obliviousSet['default'](options.idb.ttl * 2),
              // ensures we do not read messages in parrallel
              writeBlockPromise: Promise.resolve(),
              messagesCallback: null,
              readQueuePromises: [],
              db: db
            }
            /**
             * if service-workers are used,
             * we have no 'storage'-event if they post a message,
             * therefore we also have to set an interval
             */

            _readLoop(state)

            return state
          })
        }

        function _readLoop(state) {
          if (state.closed) return
          return readNewMessages(state)
            .then(function() {
              return (0, _util.sleep)(state.options.idb.fallbackInterval)
            })
            .then(function() {
              return _readLoop(state)
            })
        }

        function _filterMessage(msgObj, state) {
          if (msgObj.uuid === state.uuid) return false // send by own

          if (state.eMIs.has(msgObj.id)) return false // already emitted

          if (msgObj.data.time < state.messagesCallbackTime) return false // older then onMessageCallback

          return true
        }
        /**
         * reads all new messages from the database and emits them
         */

        function readNewMessages(state) {
          // channel already closed
          if (state.closed) return Promise.resolve() // if no one is listening, we do not need to scan for new messages

          if (!state.messagesCallback) return Promise.resolve()
          return getMessagesHigherThen(state.db, state.lastCursorId).then(function(newerMessages) {
            var useMessages = newerMessages
              /**
               * there is a bug in iOS where the msgObj can be undefined some times
               * so we filter them out
               * @link https://github.com/pubkey/broadcast-channel/issues/19
               */
              .filter(function(msgObj) {
                return !!msgObj
              })
              .map(function(msgObj) {
                if (msgObj.id > state.lastCursorId) {
                  state.lastCursorId = msgObj.id
                }

                return msgObj
              })
              .filter(function(msgObj) {
                return _filterMessage(msgObj, state)
              })
              .sort(function(msgObjA, msgObjB) {
                return msgObjA.time - msgObjB.time
              }) // sort by time

            useMessages.forEach(function(msgObj) {
              if (state.messagesCallback) {
                state.eMIs.add(msgObj.id)
                state.messagesCallback(msgObj.data)
              }
            })
            return Promise.resolve()
          })
        }

        function close(channelState) {
          channelState.closed = true
          channelState.db.close()
        }

        function postMessage(channelState, messageJson) {
          channelState.writeBlockPromise = channelState.writeBlockPromise
            .then(function() {
              return writeMessage(channelState.db, channelState.uuid, messageJson)
            })
            .then(function() {
              if ((0, _util.randomInt)(0, 10) === 0) {
                /* await (do not await) */
                cleanOldMessages(channelState.db, channelState.options.idb.ttl)
              }
            })
          return channelState.writeBlockPromise
        }

        function onMessage(channelState, fn, time) {
          channelState.messagesCallbackTime = time
          channelState.messagesCallback = fn
          readNewMessages(channelState)
        }

        function canBeUsed() {
          if (_util.isNode) return false
          var idb = getIdb()
          if (!idb) return false
          return true
        }

        function averageResponseTime(options) {
          return options.idb.fallbackInterval * 2
        }

        var _default = {
          create: create,
          close: close,
          onMessage: onMessage,
          postMessage: postMessage,
          canBeUsed: canBeUsed,
          type: type,
          averageResponseTime: averageResponseTime,
          microSeconds: microSeconds
        }
        exports['default'] = _default
      },
      {
        '../oblivious-set': '/torus/node_modules/broadcast-channel/dist/lib/oblivious-set.js',
        '../options': '/torus/node_modules/broadcast-channel/dist/lib/options.js',
        '../util.js': '/torus/node_modules/broadcast-channel/dist/lib/util.js',
        '@babel/runtime/helpers/interopRequireDefault': '/torus/node_modules/@babel/runtime/helpers/interopRequireDefault.js'
      }
    ],
    '/torus/node_modules/broadcast-channel/dist/lib/methods/localstorage.js': [
      function(require, module, exports) {
        'use strict'
        var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault')

        Object.defineProperty(exports, '__esModule', {
          value: true
        })
        exports.getLocalStorage = getLocalStorage
        exports.storageKey = storageKey
        exports.postMessage = postMessage
        exports.addStorageEventListener = addStorageEventListener
        exports.removeStorageEventListener = removeStorageEventListener
        exports.create = create
        exports.close = close
        exports.onMessage = onMessage
        exports.canBeUsed = canBeUsed
        exports.averageResponseTime = averageResponseTime
        exports['default'] = exports.type = exports.microSeconds = void 0

        var _obliviousSet = _interopRequireDefault(require('../oblivious-set'))

        var _options = require('../options')

        var _util = require('../util')

        /**
         * A localStorage-only method which uses localstorage and its 'storage'-event
         * This does not work inside of webworkers because they have no access to locastorage
         * This is basically implemented to support IE9 or your grandmothers toaster.
         * @link https://caniuse.com/#feat=namevalue-storage
         * @link https://caniuse.com/#feat=indexeddb
         */
        var microSeconds = _util.microSeconds
        exports.microSeconds = microSeconds
        var KEY_PREFIX = 'pubkey.broadcastChannel-'
        var type = 'localstorage'
        /**
         * copied from crosstab
         * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32
         */

        exports.type = type

        function getLocalStorage() {
          var localStorage
          if (typeof window === 'undefined') return null

          try {
            localStorage = window.localStorage
            localStorage = window['ie8-eventlistener/storage'] || window.localStorage
          } catch (e) {
            // New versions of Firefox throw a Security exception
            // if cookies are disabled. See
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153
          }

          return localStorage
        }

        function storageKey(channelName) {
          return KEY_PREFIX + channelName
        }
        /**
         * writes the new message to the storage
         * and fires the storage-event so other readers can find it
         */

        function postMessage(channelState, messageJson) {
          return new Promise(function(res) {
            ;(0, _util.sleep)().then(function() {
              var key = storageKey(channelState.channelName)
              var writeObj = {
                token: (0, _util.randomToken)(10),
                time: new Date().getTime(),
                data: messageJson,
                uuid: channelState.uuid
              }
              var value = JSON.stringify(writeObj)
              getLocalStorage().setItem(key, value)
              /**
               * StorageEvent does not fire the 'storage' event
               * in the window that changes the state of the local storage.
               * So we fire it manually
               */

              var ev = document.createEvent('Event')
              ev.initEvent('storage', true, true)
              ev.key = key
              ev.newValue = value
              window.dispatchEvent(ev)
              res()
            })
          })
        }

        function addStorageEventListener(channelName, fn) {
          var key = storageKey(channelName)

          var listener = function listener(ev) {
            if (ev.key === key) {
              fn(JSON.parse(ev.newValue))
            }
          }

          window.addEventListener('storage', listener)
          return listener
        }

        function removeStorageEventListener(listener) {
          window.removeEventListener('storage', listener)
        }

        function create(channelName, options) {
          options = (0, _options.fillOptionsWithDefaults)(options)

          if (!canBeUsed()) {
            throw new Error('BroadcastChannel: localstorage cannot be used')
          }

          var uuid = (0, _util.randomToken)(10)
          /**
           * eMIs
           * contains all messages that have been emitted before
           * @type {ObliviousSet}
           */

          var eMIs = new _obliviousSet['default'](options.localstorage.removeTimeout)
          var state = {
            channelName: channelName,
            uuid: uuid,
            eMIs: eMIs // emittedMessagesIds
          }
          state.listener = addStorageEventListener(channelName, function(msgObj) {
            if (!state.messagesCallback) return // no listener

            if (msgObj.uuid === uuid) return // own message

            if (!msgObj.token || eMIs.has(msgObj.token)) return // already emitted

            if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return // too old

            eMIs.add(msgObj.token)
            state.messagesCallback(msgObj.data)
          })
          return state
        }

        function close(channelState) {
          removeStorageEventListener(channelState.listener)
        }

        function onMessage(channelState, fn, time) {
          channelState.messagesCallbackTime = time
          channelState.messagesCallback = fn
        }

        function canBeUsed() {
          if (_util.isNode) return false
          var ls = getLocalStorage()
          if (!ls) return false

          try {
            var key = '__broadcastchannel_check'
            ls.setItem(key, 'works')
            ls.removeItem(key)
          } catch (e) {
            // Safari 10 in private mode will not allow write access to local
            // storage and fail with a QuotaExceededError. See
            // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes
            return false
          }

          return true
        }

        function averageResponseTime() {
          return 120
        }

        var _default = {
          create: create,
          close: close,
          onMessage: onMessage,
          postMessage: postMessage,
          canBeUsed: canBeUsed,
          type: type,
          averageResponseTime: averageResponseTime,
          microSeconds: microSeconds
        }
        exports['default'] = _default
      },
      {
        '../oblivious-set': '/torus/node_modules/broadcast-channel/dist/lib/oblivious-set.js',
        '../options': '/torus/node_modules/broadcast-channel/dist/lib/options.js',
        '../util': '/torus/node_modules/broadcast-channel/dist/lib/util.js',
        '@babel/runtime/helpers/interopRequireDefault': '/torus/node_modules/@babel/runtime/helpers/interopRequireDefault.js'
      }
    ],
    '/torus/node_modules/broadcast-channel/dist/lib/methods/native.js': [
      function(require, module, exports) {
        'use strict'

        Object.defineProperty(exports, '__esModule', {
          value: true
        })
        exports.create = create
        exports.close = close
        exports.postMessage = postMessage
        exports.onMessage = onMessage
        exports.canBeUsed = canBeUsed
        exports.averageResponseTime = averageResponseTime
        exports['default'] = exports.type = exports.microSeconds = void 0

        var _util = require('../util')

        var microSeconds = _util.microSeconds
        exports.microSeconds = microSeconds
        var type = 'native'
        exports.type = type

        function create(channelName) {
          var state = {
            messagesCallback: null,
            bc: new BroadcastChannel(channelName),
            subFns: [] // subscriberFunctions
          }

          state.bc.onmessage = function(msg) {
            if (state.messagesCallback) {
              state.messagesCallback(msg.data)
            }
          }

          return state
        }

        function close(channelState) {
          channelState.bc.close()
          channelState.subFns = []
        }

        function postMessage(channelState, messageJson) {
          channelState.bc.postMessage(messageJson, false)
        }

        function onMessage(channelState, fn) {
          channelState.messagesCallback = fn
        }

        function canBeUsed() {
          /**
           * in the electron-renderer, isNode will be true even if we are in browser-context
           * so we also check if window is undefined
           */
          if (_util.isNode && typeof window === 'undefined') return false

          if (typeof BroadcastChannel === 'function') {
            if (BroadcastChannel._pubkey) {
              throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill')
            }

            return true
          } else return false
        }

        function averageResponseTime() {
          return 100
        }

        var _default = {
          create: create,
          close: close,
          onMessage: onMessage,
          postMessage: postMessage,
          canBeUsed: canBeUsed,
          type: type,
          averageResponseTime: averageResponseTime,
          microSeconds: microSeconds
        }
        exports['default'] = _default
      },
      { '../util': '/torus/node_modules/broadcast-channel/dist/lib/util.js' }
    ],
    '/torus/node_modules/broadcast-channel/dist/lib/methods/simulate.js': [
      function(require, module, exports) {
        'use strict'
        Object.defineProperty(exports, '__esModule', {
          value: true
        })
        exports.create = create
        exports.close = close
        exports.postMessage = postMessage
        exports.onMessage = onMessage
        exports.canBeUsed = canBeUsed
        exports.averageResponseTime = averageResponseTime
        exports['default'] = exports.type = exports.microSeconds = void 0

        var _util = require('../util')

        var microSeconds = _util.microSeconds
        exports.microSeconds = microSeconds
        var type = 'simulate'
        exports.type = type
        var SIMULATE_CHANNELS = new Set()

        function create(channelName) {
          var state = {
            name: channelName,
            messagesCallback: null
          }
          SIMULATE_CHANNELS.add(state)
          return state
        }

        function close(channelState) {
          SIMULATE_CHANNELS['delete'](channelState)
        }

        function postMessage(channelState, messageJson) {
          return new Promise(function(res) {
            return setTimeout(function() {
              var channelArray = Array.from(SIMULATE_CHANNELS)
              channelArray
                .filter(function(channel) {
                  return channel.name === channelState.name
                })
                .filter(function(channel) {
                  return channel !== channelState
                })
                .filter(function(channel) {
                  return !!channel.messagesCallback
                })
                .forEach(function(channel) {
                  return channel.messagesCallback(messageJson)
                })
              res()
            }, 5)
          })
        }

        function onMessage(channelState, fn) {
          channelState.messagesCallback = fn
        }

        function canBeUsed() {
          return true
        }

        function averageResponseTime() {
          return 5
        }

        var _default = {
          create: create,
          close: close,
          onMessage: onMessage,
          postMessage: postMessage,
          canBeUsed: canBeUsed,
          type: type,
          averageResponseTime: averageResponseTime,
          microSeconds: microSeconds
        }
        exports['default'] = _default
      },
      { '../util': '/torus/node_modules/broadcast-channel/dist/lib/util.js' }
    ],
    '/torus/node_modules/broadcast-channel/dist/lib/oblivious-set.js': [
      function(require, module, exports) {
        'use strict'

        Object.defineProperty(exports, '__esModule', {
          value: true
        })
        exports['default'] = void 0

        /**
         * this is a set which automatically forgets
         * a given entry when a new entry is set and the ttl
         * of the old one is over
         * @constructor
         */
        var ObliviousSet = function ObliviousSet(ttl) {
          var set = new Set()
          var timeMap = new Map()
          this.has = set.has.bind(set)

          this.add = function(value) {
            timeMap.set(value, now())
            set.add(value)

            _removeTooOldValues()
          }

          this.clear = function() {
            set.clear()
            timeMap.clear()
          }

          function _removeTooOldValues() {
            var olderThen = now() - ttl
            var iterator = set[Symbol.iterator]()

            while (true) {
              var value = iterator.next().value
              if (!value) return // no more elements

              var time = timeMap.get(value)

              if (time < olderThen) {
                timeMap['delete'](value)
                set['delete'](value)
              } else {
                // we reached a value that is not old enough
                return
              }
            }
          }
        }

        function now() {
          return new Date().getTime()
        }

        var _default = ObliviousSet
        exports['default'] = _default
      },
      {}
    ],
    '/torus/node_modules/broadcast-channel/dist/lib/options.js': [
      function(require, module, exports) {
        'use strict'
        Object.defineProperty(exports, '__esModule', {
          value: true
        })
        exports.fillOptionsWithDefaults = fillOptionsWithDefaults

        function fillOptionsWithDefaults(options) {
          if (!options) options = {}
          options = JSON.parse(JSON.stringify(options)) // main

          if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true // indexed-db

          if (!options.idb) options.idb = {} //  after this time the messages get deleted

          if (!options.idb.ttl) options.idb.ttl = 1000 * 45
          if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150 // localstorage

          if (!options.localstorage) options.localstorage = {}
          if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60 // node

          if (!options.node) options.node = {}
          if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2 // 2 minutes;

          if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true
          return options
        }
      },
      {}
    ],
    '/torus/node_modules/broadcast-channel/dist/lib/util.js': [
      function(require, module, exports) {
        ;(function(process) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true
          })
          exports.isPromise = isPromise
          exports.sleep = sleep
          exports.randomInt = randomInt
          exports.randomToken = randomToken
          exports.microSeconds = microSeconds
          exports.isNode = void 0

          /**
           * returns true if the given object is a promise
           */
          function isPromise(obj) {
            if (obj && typeof obj.then === 'function') {
              return true
            } else {
              return false
            }
          }

          function sleep(time) {
            if (!time) time = 0
            return new Promise(function(res) {
              return setTimeout(res, time)
            })
          }

          function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min)
          }
          /**
           * https://stackoverflow.com/a/1349426/3443137
           */

          function randomToken(length) {
            if (!length) length = 5
            var text = ''
            var possible = 'abcdefghijklmnopqrstuvwxzy0123456789'

            for (var i = 0; i < length; i++) {
              text += possible.charAt(Math.floor(Math.random() * possible.length))
            }

            return text
          }

          var lastMs = 0
          var additional = 0
          /**
           * returns the current time in micro-seconds,
           * WARNING: This is a pseudo-function
           * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.
           * This is enough in browsers, and this function will not be used in nodejs.
           * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.
           */

          function microSeconds() {
            var ms = new Date().getTime()

            if (ms === lastMs) {
              additional++
              return ms * 1000 + additional
            } else {
              lastMs = ms
              additional = 0
              return ms * 1000
            }
          }
          /**
           * copied from the 'detect-node' npm module
           * We cannot use the module directly because it causes problems with rollup
           * @link https://github.com/iliakan/detect-node/blob/master/index.js
           */

          var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'
          exports.isNode = isNode
        }.call(this, require('_process')))
      },
      { _process: '/torus/node_modules/process/browser.js' }
    ],
    '/torus/node_modules/process/browser.js': [
      function(require, module, exports) {
        // shim for using process in browser
        var process = (module.exports = {})

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout
        var cachedClearTimeout

        function defaultSetTimout() {
          throw new Error('setTimeout has not been defined')
        }
        function defaultClearTimeout() {
          throw new Error('clearTimeout has not been defined')
        }
        ;(function() {
          try {
            if (typeof setTimeout === 'function') {
              cachedSetTimeout = setTimeout
            } else {
              cachedSetTimeout = defaultSetTimout
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout
          }
          try {
            if (typeof clearTimeout === 'function') {
              cachedClearTimeout = clearTimeout
            } else {
              cachedClearTimeout = defaultClearTimeout
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout
          }
        })()
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0)
          }
          // if setTimeout wasn't available but was latter defined
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout
            return setTimeout(fun, 0)
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0)
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0)
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this',
              // hopefully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0)
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker)
          }
          // if clearTimeout wasn't available but was latter defined
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout
            return clearTimeout(marker)
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker)
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker)
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this',
              // hopefully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker)
            }
          }
        }
        var queue = []
        var draining = false
        var currentQueue
        var queueIndex = -1

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return
          }
          draining = false
          if (currentQueue.length) {
            queue = currentQueue.concat(queue)
          } else {
            queueIndex = -1
          }
          if (queue.length) {
            drainQueue()
          }
        }

        function drainQueue() {
          if (draining) {
            return
          }
          var timeout = runTimeout(cleanUpNextTick)
          draining = true

          var len = queue.length
          while (len) {
            currentQueue = queue
            queue = []
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run()
              }
            }
            queueIndex = -1
            len = queue.length
          }
          currentQueue = null
          draining = false
          runClearTimeout(timeout)
        }

        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1)
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i]
            }
          }
          queue.push(new Item(fun, args))
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue)
          }
        }

        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun
          this.array = array
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array)
        }
        process.title = 'browser'
        process.browser = true
        process.env = {}
        process.argv = []
        process.version = '' // empty string to avoid regexp issues
        process.versions = {}

        function noop() {}

        process.on = noop
        process.addListener = noop
        process.once = noop
        process.off = noop
        process.removeListener = noop
        process.removeAllListeners = noop
        process.emit = noop
        process.prependListener = noop
        process.prependOnceListener = noop

        process.listeners = function(name) {
          return []
        }

        process.binding = function(name) {
          throw new Error('process.binding is not supported')
        }

        process.cwd = function() {
          return '/'
        }
        process.chdir = function(dir) {
          throw new Error('process.chdir is not supported')
        }
        process.umask = function() {
          return 0
        }
      },
      {}
    ]
  },
  {},
  ['/torus/embed.js']
)
      var bc
      var broadcastChannelOptions = {
        // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node'
        webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increase performance)
      }
      try {

        var url = new URL(location.href)
        var hash = url.hash.substr(1)
        var hashParams = hash.split('&').reduce(function(result, item) {
          const parts = item.split('=')
          result[parts[0]] = parts[1]
          return result
        }, {})
        var queryParams = {}
        for (var entry of url.searchParams.entries()) {
          queryParams[entry[0]] = entry[1]
        }
        var instanceParams = {}
        var error = ''
        if (Object.keys(hashParams).length > 0 && hashParams.state) {
          instanceParams = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(hashParams.state)))) || {}
          if (hashParams.error) error = hashParams.error
        } else if (Object.keys(queryParams).length > 0 && queryParams.state) {
          instanceParams = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(queryParams.state)))) || {}
          if (queryParams.error) error = queryParams.error
        }
        bc = new broadcastChannelLib.BroadcastChannel('redirect_channel_' + instanceParams.instanceId, broadcastChannelOptions)
        bc.postMessage({
          data: {
            verifier: instanceParams.verifier,
            verifierParams: hashParams
          },
          error: error
        }).then(function() {
          bc.close()
        })
      } catch (err) {
        console.error(err, 'something went wrong')
        bc && bc.close()
        window.close()
      }
    </script>
  </body>
</html>${''}
`
        ])
      )
    )
  }
})

self.__precacheManifest = [
  {
    url: '/js/app.js'
  }
].concat(self.__precacheManifest || [])
precacheAndRoute(self.__precacheManifest, {})

